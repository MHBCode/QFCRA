//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ActivityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param activityCategoryId (optional) 
     * @return OK
     */
    types(activityCategoryId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_activity_types?";
        if (activityCategoryId === null)
            throw new Error("The parameter 'activityCategoryId' cannot be null.");
        else if (activityCategoryId !== undefined)
            url_ += "activityCategoryId=" + encodeURIComponent("" + activityCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    categories(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_activity_categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategories(_response);
        });
    }

    protected processCategories(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class AvailableClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param activityTypeID (optional) 
     * @return OK
     */
    products(activityTypeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_available_products?";
        if (activityTypeID === null)
            throw new Error("The parameter 'activityTypeID' cannot be null.");
        else if (activityTypeID !== undefined)
            url_ += "activityTypeID=" + encodeURIComponent("" + activityTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProducts(_response);
        });
    }

    protected processProducts(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ScopeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param activityCategoryId (optional) 
     * @return OK
     */
    revNum(firmId: number | undefined, activityCategoryId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_current_scope_revNum?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (activityCategoryId === null)
            throw new Error("The parameter 'activityCategoryId' cannot be null.");
        else if (activityCategoryId !== undefined)
            url_ += "activityCategoryId=" + encodeURIComponent("" + activityCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevNum(_response);
        });
    }

    protected processRevNum(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class FirmClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    scope(body: DeleteScopeObject | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/delete_firm_scope";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScope(_response);
        });
    }

    protected processScope(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param firmScopeID (optional) 
     * @param firmScopeRevNo (optional) 
     * @param firmApplicationTypeId (optional) 
     * @param isWithdrawnActivityReqdFlag (optional) 
     * @return OK
     */
    activities(firmId: number | undefined, firmScopeID: number | undefined, firmScopeRevNo: number | undefined, firmApplicationTypeId: number | undefined, isWithdrawnActivityReqdFlag: string | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_firm_activities?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmScopeID === null)
            throw new Error("The parameter 'firmScopeID' cannot be null.");
        else if (firmScopeID !== undefined)
            url_ += "firmScopeID=" + encodeURIComponent("" + firmScopeID) + "&";
        if (firmScopeRevNo === null)
            throw new Error("The parameter 'firmScopeRevNo' cannot be null.");
        else if (firmScopeRevNo !== undefined)
            url_ += "firmScopeRevNo=" + encodeURIComponent("" + firmScopeRevNo) + "&";
        if (firmApplicationTypeId === null)
            throw new Error("The parameter 'firmApplicationTypeId' cannot be null.");
        else if (firmApplicationTypeId !== undefined)
            url_ += "firmApplicationTypeId=" + encodeURIComponent("" + firmApplicationTypeId) + "&";
        if (isWithdrawnActivityReqdFlag === null)
            throw new Error("The parameter 'isWithdrawnActivityReqdFlag' cannot be null.");
        else if (isWithdrawnActivityReqdFlag !== undefined)
            url_ += "isWithdrawnActivityReqdFlag=" + encodeURIComponent("" + isWithdrawnActivityReqdFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivities(_response);
        });
    }

    protected processActivities(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    users(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_inactive_firm_users?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmName (optional) 
     * @param firmId (optional) 
     * @return OK
     */
    name(firmName: string | undefined, firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_exist_firm_name?";
        if (firmName === null)
            throw new Error("The parameter 'firmName' cannot be null.");
        else if (firmName !== undefined)
            url_ += "firmName=" + encodeURIComponent("" + firmName) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processName(_response);
        });
    }

    protected processName(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    users(body: FirmUsersObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/insert_update_firm_users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    users(body: DeleteFirmUserObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/delete_firm_users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    id(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_sector_type_by_firm_id?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processId(_response);
        });
    }

    protected processId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    id(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_legal_status_type_by_firm_id?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processId(_response);
        });
    }

    protected processId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param qfcNum (optional) 
     * @return OK
     */
    details(qfcNum: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_details?";
        if (qfcNum === null)
            throw new Error("The parameter 'qfcNum' cannot be null.");
        else if (qfcNum !== undefined)
            url_ += "qfcNum=" + encodeURIComponent("" + qfcNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param assnLevelId (optional) 
     * @return OK
     */
    user(firmId: number | undefined, assnLevelId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_user?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (assnLevelId === null)
            throw new Error("The parameter 'assnLevelId' cannot be null.");
        else if (assnLevelId !== undefined)
            url_ += "assnLevelId=" + encodeURIComponent("" + assnLevelId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    form(body: InsertFirmFormObj | undefined): Promise<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/insert_update_firm_form";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForm(_response);
        });
    }

    protected processForm(response: Response): Promise<Int32BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Int32BaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    authorised(firmId: number | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_firm_authorised?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthorised(_response);
        });
    }

    protected processAuthorised(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }

    /**
     * @param noticeID (optional) 
     * @return OK
     */
    notice(noticeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/get_firm_notice?";
        if (noticeID === null)
            throw new Error("The parameter 'noticeID' cannot be null.");
        else if (noticeID !== undefined)
            url_ += "noticeID=" + encodeURIComponent("" + noticeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotice(_response);
        });
    }

    protected processNotice(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmRiskID (optional) 
     * @param firmRiskRevNum (optional) 
     * @return OK
     */
    risk(firmRiskID: number | undefined, firmRiskRevNum: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/delete_firm_risk?";
        if (firmRiskID === null)
            throw new Error("The parameter 'firmRiskID' cannot be null.");
        else if (firmRiskID !== undefined)
            url_ += "firmRiskID=" + encodeURIComponent("" + firmRiskID) + "&";
        if (firmRiskRevNum === null)
            throw new Error("The parameter 'firmRiskRevNum' cannot be null.");
        else if (firmRiskRevNum !== undefined)
            url_ += "firmRiskRevNum=" + encodeURIComponent("" + firmRiskRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRisk(_response);
        });
    }

    protected processRisk(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rmp(body: InsertFirmRMPObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/insert_update_firm_rmp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRmp(_response);
        });
    }

    protected processRmp(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    risks(body: InsertFirmRiskObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/insert_update_firm_risks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRisks(_response);
        });
    }

    protected processRisks(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class PrudentialClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param firmScopeID (optional) 
     * @param firmScopeRevNo (optional) 
     * @return OK
     */
    category(firmId: number | undefined, firmScopeID: number | undefined, firmScopeRevNo: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_prudential_category?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmScopeID === null)
            throw new Error("The parameter 'firmScopeID' cannot be null.");
        else if (firmScopeID !== undefined)
            url_ += "firmScopeID=" + encodeURIComponent("" + firmScopeID) + "&";
        if (firmScopeRevNo === null)
            throw new Error("The parameter 'firmScopeRevNo' cannot be null.");
        else if (firmScopeRevNo !== undefined)
            url_ += "firmScopeRevNo=" + encodeURIComponent("" + firmScopeRevNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategory(_response);
        });
    }

    protected processCategory(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class SectorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param firmScopeID (optional) 
     * @param firmScopeRevNo (optional) 
     * @return OK
     */
    details(firmId: number | undefined, firmScopeID: number | undefined, firmScopeRevNo: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_sector_details?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmScopeID === null)
            throw new Error("The parameter 'firmScopeID' cannot be null.");
        else if (firmScopeID !== undefined)
            url_ += "firmScopeID=" + encodeURIComponent("" + firmScopeID) + "&";
        if (firmScopeRevNo === null)
            throw new Error("The parameter 'firmScopeRevNo' cannot be null.");
        else if (firmScopeRevNo !== undefined)
            url_ += "firmScopeRevNo=" + encodeURIComponent("" + firmScopeRevNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class IslamicClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param firmScopeID (optional) 
     * @param scopeRevNo (optional) 
     * @return OK
     */
    finance(firmId: number | undefined, firmScopeID: number | undefined, scopeRevNo: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_islamic_finance?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmScopeID === null)
            throw new Error("The parameter 'firmScopeID' cannot be null.");
        else if (firmScopeID !== undefined)
            url_ += "firmScopeID=" + encodeURIComponent("" + firmScopeID) + "&";
        if (scopeRevNo === null)
            throw new Error("The parameter 'scopeRevNo' cannot be null.");
        else if (scopeRevNo !== undefined)
            url_ += "scopeRevNo=" + encodeURIComponent("" + scopeRevNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFinance(_response);
        });
    }

    protected processFinance(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    activity(body: FirmScopeDto | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/delete_islamic_activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivity(_response);
        });
    }

    protected processActivity(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }
}

export class RetClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param prudCatId (optional) 
     * @return OK
     */
    type(prudCatId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_prud_ret_type?";
        if (prudCatId === null)
            throw new Error("The parameter 'prudCatId' cannot be null.");
        else if (prudCatId !== undefined)
            url_ += "prudCatId=" + encodeURIComponent("" + prudCatId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ParentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param activityType (optional) 
     * @return OK
     */
    activity(activityType: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/is_parent_activity?";
        if (activityType === null)
            throw new Error("The parameter 'activityType' cannot be null.");
        else if (activityType !== undefined)
            url_ += "activityType=" + encodeURIComponent("" + activityType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivity(_response);
        });
    }

    protected processActivity(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param otherEntityID (optional) 
     * @param relatedEntityID (optional) 
     * @param output (optional) 
     * @return OK
     */
    entity(otherEntityID: number | undefined, relatedEntityID: number | undefined, output: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ParentEntity/delete_parent_entity?";
        if (otherEntityID === null)
            throw new Error("The parameter 'otherEntityID' cannot be null.");
        else if (otherEntityID !== undefined)
            url_ += "otherEntityID=" + encodeURIComponent("" + otherEntityID) + "&";
        if (relatedEntityID === null)
            throw new Error("The parameter 'relatedEntityID' cannot be null.");
        else if (relatedEntityID !== undefined)
            url_ += "relatedEntityID=" + encodeURIComponent("" + relatedEntityID) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEntity(_response);
        });
    }

    protected processEntity(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class InClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param activityTypeID (optional) 
     * @return OK
     */
    hirerchy(activityTypeID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_activity_in_hirerchy?";
        if (activityTypeID === null)
            throw new Error("The parameter 'activityTypeID' cannot be null.");
        else if (activityTypeID !== undefined)
            url_ += "activityTypeID=" + encodeURIComponent("" + activityTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHirerchy(_response);
        });
    }

    protected processHirerchy(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param objectId (optional) 
     * @param roleId (optional) 
     * @return OK
     */
    role(objectId: number | undefined, roleId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Security/get_users_in_role?";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRole(_response);
        });
    }

    protected processRole(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ReferencedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param firmScopeID (optional) 
     * @param scopeRevNo (optional) 
     * @return OK
     */
    ais(firmId: number | undefined, firmScopeID: number | undefined, scopeRevNo: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/is_current_scope_activity_referenced_ais?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmScopeID === null)
            throw new Error("The parameter 'firmScopeID' cannot be null.");
        else if (firmScopeID !== undefined)
            url_ += "firmScopeID=" + encodeURIComponent("" + firmScopeID) + "&";
        if (scopeRevNo === null)
            throw new Error("The parameter 'scopeRevNo' cannot be null.");
        else if (scopeRevNo !== undefined)
            url_ += "scopeRevNo=" + encodeURIComponent("" + scopeRevNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAis(_response);
        });
    }

    protected processAis(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ConditionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    types(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/get_scope_condition_types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class AuthorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    scope(body: SaveUpdateAuthorizedScope | undefined): Promise<FirmScopeDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/save_update_author_scope";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScope(_response);
        });
    }

    protected processScope(response: Response): Promise<FirmScopeDtoBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FirmScopeDtoBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FirmScopeDtoBaseResponse>(null as any);
    }
}

export class LicensedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    scope(body: SaveUpdateLicensedScopeObj | undefined): Promise<FirmScopeDtoBaseResponse> {
        let url_ = this.baseUrl + "/api/Activity/save_update_licensed_scope";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScope(_response);
        });
    }

    protected processScope(response: Response): Promise<FirmScopeDtoBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FirmScopeDtoBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FirmScopeDtoBaseResponse>(null as any);
    }
}

export class AddressClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param entityTypeId (optional) 
     * @param entityId (optional) 
     * @param contactAssnId (optional) 
     * @param userId (optional) 
     * @param opTypeId (optional) 
     * @param addressId (optional) 
     * @param objectId (optional) 
     * @param objectInstanceId (optional) 
     * @param objectInstanceRevNum (optional) 
     * @param sourceObjectID (optional) 
     * @param sourceObjectInstanceId (optional) 
     * @param sourceObjectInstanceRevNum (optional) 
     * @param contanctID (optional) 
     * @return OK
     */
    list(entityTypeId: number | undefined, entityId: number | undefined, contactAssnId: number | undefined, userId: number | undefined, opTypeId: number | undefined, addressId: number | undefined, objectId: number | undefined, objectInstanceId: number | undefined, objectInstanceRevNum: number | undefined, sourceObjectID: number | undefined, sourceObjectInstanceId: number | undefined, sourceObjectInstanceRevNum: number | undefined, contanctID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Address/get_address_list?";
        if (entityTypeId === null)
            throw new Error("The parameter 'entityTypeId' cannot be null.");
        else if (entityTypeId !== undefined)
            url_ += "entityTypeId=" + encodeURIComponent("" + entityTypeId) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (contactAssnId === null)
            throw new Error("The parameter 'contactAssnId' cannot be null.");
        else if (contactAssnId !== undefined)
            url_ += "contactAssnId=" + encodeURIComponent("" + contactAssnId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (opTypeId === null)
            throw new Error("The parameter 'opTypeId' cannot be null.");
        else if (opTypeId !== undefined)
            url_ += "opTypeId=" + encodeURIComponent("" + opTypeId) + "&";
        if (addressId === null)
            throw new Error("The parameter 'addressId' cannot be null.");
        else if (addressId !== undefined)
            url_ += "addressId=" + encodeURIComponent("" + addressId) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (objectInstanceId === null)
            throw new Error("The parameter 'objectInstanceId' cannot be null.");
        else if (objectInstanceId !== undefined)
            url_ += "objectInstanceId=" + encodeURIComponent("" + objectInstanceId) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "objectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        if (sourceObjectID === null)
            throw new Error("The parameter 'sourceObjectID' cannot be null.");
        else if (sourceObjectID !== undefined)
            url_ += "sourceObjectID=" + encodeURIComponent("" + sourceObjectID) + "&";
        if (sourceObjectInstanceId === null)
            throw new Error("The parameter 'sourceObjectInstanceId' cannot be null.");
        else if (sourceObjectInstanceId !== undefined)
            url_ += "sourceObjectInstanceId=" + encodeURIComponent("" + sourceObjectInstanceId) + "&";
        if (sourceObjectInstanceRevNum === null)
            throw new Error("The parameter 'sourceObjectInstanceRevNum' cannot be null.");
        else if (sourceObjectInstanceRevNum !== undefined)
            url_ += "sourceObjectInstanceRevNum=" + encodeURIComponent("" + sourceObjectInstanceRevNum) + "&";
        if (contanctID === null)
            throw new Error("The parameter 'contanctID' cannot be null.");
        else if (contanctID !== undefined)
            url_ += "contanctID=" + encodeURIComponent("" + contanctID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class TypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param contactId (optional) 
     * @param addressTypeId (optional) 
     * @param valId (optional) 
     * @param entityTypeId (optional) 
     * @param entityId (optional) 
     * @param contactAssnId (optional) 
     * @param objectId (optional) 
     * @param objectInstanceId (optional) 
     * @param objectInstanceRevNum (optional) 
     * @param sourceObjectId (optional) 
     * @param sourceObjectInstanceId (optional) 
     * @param sourceObjectInstanceRevNum (optional) 
     * @return OK
     */
    history(firmId: number | undefined, contactId: number | undefined, addressTypeId: number | undefined, valId: boolean | undefined, entityTypeId: number | undefined, entityId: number | undefined, contactAssnId: number | undefined, objectId: number | undefined, objectInstanceId: number | undefined, objectInstanceRevNum: number | undefined, sourceObjectId: number | undefined, sourceObjectInstanceId: number | undefined, sourceObjectInstanceRevNum: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Address/get_address_type_history?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (addressTypeId === null)
            throw new Error("The parameter 'addressTypeId' cannot be null.");
        else if (addressTypeId !== undefined)
            url_ += "addressTypeId=" + encodeURIComponent("" + addressTypeId) + "&";
        if (valId === null)
            throw new Error("The parameter 'valId' cannot be null.");
        else if (valId !== undefined)
            url_ += "valId=" + encodeURIComponent("" + valId) + "&";
        if (entityTypeId === null)
            throw new Error("The parameter 'entityTypeId' cannot be null.");
        else if (entityTypeId !== undefined)
            url_ += "entityTypeId=" + encodeURIComponent("" + entityTypeId) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (contactAssnId === null)
            throw new Error("The parameter 'contactAssnId' cannot be null.");
        else if (contactAssnId !== undefined)
            url_ += "contactAssnId=" + encodeURIComponent("" + contactAssnId) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "ObjectId=" + encodeURIComponent("" + objectId) + "&";
        if (objectInstanceId === null)
            throw new Error("The parameter 'objectInstanceId' cannot be null.");
        else if (objectInstanceId !== undefined)
            url_ += "ObjectInstanceId=" + encodeURIComponent("" + objectInstanceId) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "ObjectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        if (sourceObjectId === null)
            throw new Error("The parameter 'sourceObjectId' cannot be null.");
        else if (sourceObjectId !== undefined)
            url_ += "SourceObjectId=" + encodeURIComponent("" + sourceObjectId) + "&";
        if (sourceObjectInstanceId === null)
            throw new Error("The parameter 'sourceObjectInstanceId' cannot be null.");
        else if (sourceObjectInstanceId !== undefined)
            url_ += "SourceObjectInstanceId=" + encodeURIComponent("" + sourceObjectInstanceId) + "&";
        if (sourceObjectInstanceRevNum === null)
            throw new Error("The parameter 'sourceObjectInstanceRevNum' cannot be null.");
        else if (sourceObjectInstanceRevNum !== undefined)
            url_ += "SourceObjectInstanceRevNum=" + encodeURIComponent("" + sourceObjectInstanceRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param entityTypeId (optional) 
     * @param entityId (optional) 
     * @param contactId (optional) 
     * @param contactAssnId (optional) 
     * @param output (optional) 
     * @return OK
     */
    exists(firmId: number | undefined, entityTypeId: number | undefined, entityId: number | undefined, contactId: number | undefined, contactAssnId: number | undefined, output: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/is_contact_type_exists?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (entityTypeId === null)
            throw new Error("The parameter 'entityTypeId' cannot be null.");
        else if (entityTypeId !== undefined)
            url_ += "EntityTypeId=" + encodeURIComponent("" + entityTypeId) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (contactAssnId === null)
            throw new Error("The parameter 'contactAssnId' cannot be null.");
        else if (contactAssnId !== undefined)
            url_ += "contactAssnId=" + encodeURIComponent("" + contactAssnId) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExists(_response);
        });
    }

    protected processExists(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param refNo (optional) 
     * @param fileNo (optional) 
     * @param docID (optional) 
     * @return OK
     */
    file(refNo: string | undefined, fileNo: string | undefined, docID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_sub_type_file?";
        if (refNo === null)
            throw new Error("The parameter 'refNo' cannot be null.");
        else if (refNo !== undefined)
            url_ += "refNo=" + encodeURIComponent("" + refNo) + "&";
        if (fileNo === null)
            throw new Error("The parameter 'fileNo' cannot be null.");
        else if (fileNo !== undefined)
            url_ += "fileNo=" + encodeURIComponent("" + fileNo) + "&";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFile(_response);
        });
    }

    protected processFile(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param flag (optional) 
     * @return OK
     */
    list(flag: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_type_list?";
        if (flag === null)
            throw new Error("The parameter 'flag' cannot be null.");
        else if (flag !== undefined)
            url_ += "flag=" + encodeURIComponent("" + flag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param objectTypeTable (optional) 
     * @param objectOpTypeId (optional) 
     * @return OK
     */
    table(userId: number | undefined, objectTypeTable: string | undefined, objectOpTypeId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Security/get_object_type_table?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (objectTypeTable === null)
            throw new Error("The parameter 'objectTypeTable' cannot be null.");
        else if (objectTypeTable !== undefined)
            url_ += "objectTypeTable=" + encodeURIComponent("" + objectTypeTable) + "&";
        if (objectOpTypeId === null)
            throw new Error("The parameter 'objectOpTypeId' cannot be null.");
        else if (objectOpTypeId !== undefined)
            url_ += "objectOpTypeId=" + encodeURIComponent("" + objectOpTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTable(_response);
        });
    }

    protected processTable(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    id(body: UpdateWaiverTypeObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/update_waiver_type_id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processId(_response);
        });
    }

    protected processId(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class DeleteClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param addressId (optional) 
     * @param addressAssnId (optional) 
     * @param lastModifiedBy (optional) 
     * @param output (optional) 
     * @return OK
     */
    address(addressId: number | undefined, addressAssnId: number | undefined, lastModifiedBy: number | undefined, output: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Address/delete_address?";
        if (addressId === null)
            throw new Error("The parameter 'addressId' cannot be null.");
        else if (addressId !== undefined)
            url_ += "addressId=" + encodeURIComponent("" + addressId) + "&";
        if (addressAssnId === null)
            throw new Error("The parameter 'addressAssnId' cannot be null.");
        else if (addressAssnId !== undefined)
            url_ += "addressAssnId=" + encodeURIComponent("" + addressAssnId) + "&";
        if (lastModifiedBy === null)
            throw new Error("The parameter 'lastModifiedBy' cannot be null.");
        else if (lastModifiedBy !== undefined)
            url_ += "lastModifiedBy=" + encodeURIComponent("" + lastModifiedBy) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddress(_response);
        });
    }

    protected processAddress(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    recipients(docID: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/delete_recipients?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecipients(_response);
        });
    }

    protected processRecipients(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @param objectId (optional) 
     * @param objectInstanceId (optional) 
     * @param objectInstanceRevNum (optional) 
     * @return OK
     */
    document(docID: number | undefined, objectId: number | undefined, objectInstanceId: number | undefined, objectInstanceRevNum: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/delete_document?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (objectInstanceId === null)
            throw new Error("The parameter 'objectInstanceId' cannot be null.");
        else if (objectInstanceId !== undefined)
            url_ += "objectInstanceId=" + encodeURIComponent("" + objectInstanceId) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "ObjectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocument(_response);
        });
    }

    protected processDocument(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param relatedEntityId (optional) 
     * @return OK
     */
    regulator(relatedEntityId: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ParentEntity/delete_regulator?";
        if (relatedEntityId === null)
            throw new Error("The parameter 'relatedEntityId' cannot be null.");
        else if (relatedEntityId !== undefined)
            url_ += "relatedEntityId=" + encodeURIComponent("" + relatedEntityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegulator(_response);
        });
    }

    protected processRegulator(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param rmpID (optional) 
     * @return OK
     */
    rmp(rmpID: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Risk/delete_rmp?";
        if (rmpID === null)
            throw new Error("The parameter 'rmpID' cannot be null.");
        else if (rmpID !== undefined)
            url_ += "rmpID=" + encodeURIComponent("" + rmpID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRmp(_response);
        });
    }

    protected processRmp(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class SaveClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addresses(body: AddressDto[] | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Address/save_addresses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddresses(_response);
        });
    }

    protected processAddresses(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    escalation(body: EscalationObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Breach/save_escalation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEscalation(_response);
        });
    }

    protected processEscalation(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class UpdateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    application(body: InsertFirmParamsObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Application/insert_update_application";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplication(_response);
        });
    }

    protected processApplication(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    supervision_data(body: InsertUpdateSupervisionObj | undefined): Promise<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/insert_update_supervision data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupervision_data(_response);
        });
    }

    protected processSupervision_data(response: Response): Promise<Int32BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Int32BaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    schedulink(body: InsertDocObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/insert_update_schedulink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSchedulink(_response);
        });
    }

    protected processSchedulink(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ApplicationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(body: IsertFirmStatusObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Application/insert_application_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param firmApplID (optional) 
     * @param firmId (optional) 
     * @param firmApplTypeID (optional) 
     * @param getLatest (optional) 
     * @return OK
     */
    status(firmApplID: number | undefined, firmId: number | undefined, firmApplTypeID: number | undefined, getLatest: boolean | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Application/get_application_status?";
        if (firmApplID === null)
            throw new Error("The parameter 'firmApplID' cannot be null.");
        else if (firmApplID !== undefined)
            url_ += "firmApplID=" + encodeURIComponent("" + firmApplID) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmApplTypeID === null)
            throw new Error("The parameter 'firmApplTypeID' cannot be null.");
        else if (firmApplTypeID !== undefined)
            url_ += "firmApplTypeID=" + encodeURIComponent("" + firmApplTypeID) + "&";
        if (getLatest === null)
            throw new Error("The parameter 'getLatest' cannot be null.");
        else if (getLatest !== undefined)
            url_ += "getLatest=" + encodeURIComponent("" + getLatest) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class GetClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param applicationTypeId (optional) 
     * @return OK
     */
    applications(firmId: number | undefined, applicationTypeId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Application/get_applications?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (applicationTypeId === null)
            throw new Error("The parameter 'applicationTypeId' cannot be null.");
        else if (applicationTypeId !== undefined)
            url_ += "applicationTypeId=" + encodeURIComponent("" + applicationTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplications(_response);
        });
    }

    protected processApplications(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param qfcNum (optional) 
     * @param contactId (optional) 
     * @return OK
     */
    addresses(qfcNum: string | undefined, contactId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_addresses?";
        if (qfcNum === null)
            throw new Error("The parameter 'qfcNum' cannot be null.");
        else if (qfcNum !== undefined)
            url_ += "qfcNum=" + encodeURIComponent("" + qfcNum) + "&";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddresses(_response);
        });
    }

    protected processAddresses(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    firms(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFirms(_response);
        });
    }

    protected processFirms(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    firm(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFirm(_response);
        });
    }

    protected processFirm(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    auditors(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_auditors?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuditors(_response);
        });
    }

    protected processAuditors(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param objectId (optional) 
     * @param objectInstanceId (optional) 
     * @return OK
     */
    revision(objectId: number | undefined, objectInstanceId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/get_revision?";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (objectInstanceId === null)
            throw new Error("The parameter 'objectInstanceId' cannot be null.");
        else if (objectInstanceId !== undefined)
            url_ += "objectInstanceId=" + encodeURIComponent("" + objectInstanceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevision(_response);
        });
    }

    protected processRevision(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param objectId (optional) 
     * @param objectInstanceId (optional) 
     * @param objectInstanceRevNum (optional) 
     * @return OK
     */
    document(objectId: number | undefined, objectInstanceId: number | undefined, objectInstanceRevNum: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/get_document?";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (objectInstanceId === null)
            throw new Error("The parameter 'objectInstanceId' cannot be null.");
        else if (objectInstanceId !== undefined)
            url_ += "objectInstanceId=" + encodeURIComponent("" + objectInstanceId) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "ObjectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDocument(_response);
        });
    }

    protected processDocument(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    users(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/get_users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class StatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param applicationTypeId (optional) 
     * @return OK
     */
    current(firmId: number | undefined, applicationTypeId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Application/get_application_status_current?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (applicationTypeId === null)
            throw new Error("The parameter 'applicationTypeId' cannot be null.");
        else if (applicationTypeId !== undefined)
            url_ += "applicationTypeId=" + encodeURIComponent("" + applicationTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrent(_response);
        });
    }

    protected processCurrent(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    type(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_legal_status_type?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param currentFirmApplStatusTypeID (optional) 
     * @param currentFirmApplStatusDate (optional) 
     * @param firmOpType (optional) 
     * @return OK
     */
    date(firmId: number | undefined, currentFirmApplStatusTypeID: number | undefined, currentFirmApplStatusDate: string | undefined, firmOpType: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_valid_firm_current_status_date?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (currentFirmApplStatusTypeID === null)
            throw new Error("The parameter 'currentFirmApplStatusTypeID' cannot be null.");
        else if (currentFirmApplStatusTypeID !== undefined)
            url_ += "currentFirmApplStatusTypeID=" + encodeURIComponent("" + currentFirmApplStatusTypeID) + "&";
        if (currentFirmApplStatusDate === null)
            throw new Error("The parameter 'currentFirmApplStatusDate' cannot be null.");
        else if (currentFirmApplStatusDate !== undefined)
            url_ += "currentFirmApplStatusDate=" + encodeURIComponent("" + currentFirmApplStatusDate) + "&";
        if (firmOpType === null)
            throw new Error("The parameter 'firmOpType' cannot be null.");
        else if (firmOpType !== undefined)
            url_ += "firmOpType=" + encodeURIComponent("" + firmOpType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDate(_response);
        });
    }

    protected processDate(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    id(body: ObjectWFDetailsObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/update_wf_status_id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processId(_response);
        });
    }

    protected processId(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    id(body: UpdateRMPObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/update_rmp_wf_status_id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processId(_response);
        });
    }

    protected processId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    id(body: UpdateRMPInitialObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/update_rmp_initial_signoff_status_id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processId(_response);
        });
    }

    protected processId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    type(body: RMPStatusObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/update_wf_status_type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    id(body: RiskActionStatusObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/update_risk_action_item_wf_status_id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processId(_response);
        });
    }

    protected processId(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    types(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/get_waiver_status_types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class AppllicationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param applicationTypeId (optional) 
     * @return OK
     */
    type(firmId: number | undefined, applicationTypeId: number | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Application/check_firm_appllication_type?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (applicationTypeId === null)
            throw new Error("The parameter 'applicationTypeId' cannot be null.");
        else if (applicationTypeId !== undefined)
            url_ += "applicationTypeId=" + encodeURIComponent("" + applicationTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }
}

export class IsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    firmLicensed(firmId: number | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Application/is_firmLicensed?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFirmLicensed(_response);
        });
    }

    protected processFirmLicensed(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }
}

export class ClassifyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param appReportId (optional) 
     * @return OK
     */
    by(appReportId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/AppReport/get_app_classify_by?";
        if (appReportId === null)
            throw new Error("The parameter 'appReportId' cannot be null.");
        else if (appReportId !== undefined)
            url_ += "appReportId=" + encodeURIComponent("" + appReportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBy(_response);
        });
    }

    protected processBy(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ReportClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    details(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/AppReport/get_contact_report_details";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @return OK
     */
    reviewed(objectID: number | undefined, objectInstanceID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReturnView/get_document_id_report_reviewed?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReviewed(_response);
        });
    }

    protected processReviewed(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class AppClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    roles(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/AppRoles/get_app_roles?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoles(_response);
        });
    }

    protected processRoles(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    history(userId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/AppRoles/get_user_history?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    access(body: InsertUserRoles | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/AppRoles/save_user_access";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccess(_response);
        });
    }

    protected processAccess(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param assnLevelId (optional) 
     * @param userId (optional) 
     * @param displayHistory (optional) 
     * @param loginuserId (optional) 
     * @return OK
     */
    search(firmId: number | undefined, assnLevelId: number | undefined, userId: number | undefined, displayHistory: boolean | undefined, loginuserId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_user_search?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (assnLevelId === null)
            throw new Error("The parameter 'assnLevelId' cannot be null.");
        else if (assnLevelId !== undefined)
            url_ += "assnLevelId=" + encodeURIComponent("" + assnLevelId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (displayHistory === null)
            throw new Error("The parameter 'displayHistory' cannot be null.");
        else if (displayHistory !== undefined)
            url_ += "displayHistory=" + encodeURIComponent("" + displayHistory) + "&";
        if (loginuserId === null)
            throw new Error("The parameter 'loginuserId' cannot be null.");
        else if (loginuserId !== undefined)
            url_ += "loginuserId=" + encodeURIComponent("" + loginuserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param activeDirectoryUserName (optional) 
     * @return OK
     */
    details(activeDirectoryUserName: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Security/get_user_details?";
        if (activeDirectoryUserName === null)
            throw new Error("The parameter 'activeDirectoryUserName' cannot be null.");
        else if (activeDirectoryUserName !== undefined)
            url_ += "activeDirectoryUserName=" + encodeURIComponent("" + activeDirectoryUserName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    roles(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Security/get_user_roles?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoles(_response);
        });
    }

    protected processRoles(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    profile(body: UpdateUserProfileObj | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/update_user_profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfile(_response);
        });
    }

    protected processProfile(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }
}

export class BreachClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param breachID (optional) 
     * @param breachrevNum (optional) 
     * @param roleId (optional) 
     * @param objectOpTypeId (optional) 
     * @return OK
     */
    details(breachID: number | undefined, breachrevNum: number | undefined, roleId: number | undefined, objectOpTypeId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Breach/get_breach_details?";
        if (breachID === null)
            throw new Error("The parameter 'breachID' cannot be null.");
        else if (breachID !== undefined)
            url_ += "breachID=" + encodeURIComponent("" + breachID) + "&";
        if (breachrevNum === null)
            throw new Error("The parameter 'breachrevNum' cannot be null.");
        else if (breachrevNum !== undefined)
            url_ += "breachrevNum=" + encodeURIComponent("" + breachrevNum) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (objectOpTypeId === null)
            throw new Error("The parameter 'objectOpTypeId' cannot be null.");
        else if (objectOpTypeId !== undefined)
            url_ += "objectOpTypeId=" + encodeURIComponent("" + objectOpTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param objectId (optional) 
     * @param breachID (optional) 
     * @param breachRevNum (optional) 
     * @param output (optional) 
     * @return OK
     */
    detail(objectId: number | undefined, breachID: number | undefined, breachRevNum: number | undefined, output: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Breach/delete_breach_detail?";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (breachID === null)
            throw new Error("The parameter 'breachID' cannot be null.");
        else if (breachID !== undefined)
            url_ += "breachID=" + encodeURIComponent("" + breachID) + "&";
        if (breachRevNum === null)
            throw new Error("The parameter 'breachRevNum' cannot be null.");
        else if (breachRevNum !== undefined)
            url_ += "breachRevNum=" + encodeURIComponent("" + breachRevNum) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetail(_response);
        });
    }

    protected processDetail(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ToClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param breachID (optional) 
     * @param breachRevNumber (optional) 
     * @return OK
     */
    lrc(breachID: number | undefined, breachRevNumber: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Breach/check_passed_to_lrc?";
        if (breachID === null)
            throw new Error("The parameter 'breachID' cannot be null.");
        else if (breachID !== undefined)
            url_ += "breachID=" + encodeURIComponent("" + breachID) + "&";
        if (breachRevNumber === null)
            throw new Error("The parameter 'breachRevNumber' cannot be null.");
        else if (breachRevNumber !== undefined)
            url_ += "breachRevNumber=" + encodeURIComponent("" + breachRevNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLrc(_response);
        });
    }

    protected processLrc(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param noticeID (optional) 
     * @param createBy (optional) 
     * @return OK
     */
    template(noticeID: number | undefined, createBy: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/convert_notice_to_template?";
        if (noticeID === null)
            throw new Error("The parameter 'noticeID' cannot be null.");
        else if (noticeID !== undefined)
            url_ += "noticeID=" + encodeURIComponent("" + noticeID) + "&";
        if (createBy === null)
            throw new Error("The parameter 'createBy' cannot be null.");
        else if (createBy !== undefined)
            url_ += "createBy=" + encodeURIComponent("" + createBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemplate(_response);
        });
    }

    protected processTemplate(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    publish(body: SaveCommentObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReturnView/save_comments_to_publish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    pr(body: UpdatePublishObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/update_waiver_published_to_pr";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPr(_response);
        });
    }

    protected processPr(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class EnforcementClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @param firmId (optional) 
     * @param enforcementAndDisciplinaryActnID (optional) 
     * @return OK
     */
    data(userId: number | undefined, firmId: number | undefined, enforcementAndDisciplinaryActnID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Breach/get_enforcement_data?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (enforcementAndDisciplinaryActnID === null)
            throw new Error("The parameter 'enforcementAndDisciplinaryActnID' cannot be null.");
        else if (enforcementAndDisciplinaryActnID !== undefined)
            url_ += "enforcementAndDisciplinaryActnID=" + encodeURIComponent("" + enforcementAndDisciplinaryActnID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ContactClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    details(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_all_contact_details?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }
    
    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param contactAssId (optional) 
     * @param output (optional) 
     * @return OK
     */
    details(contactId: number | undefined, contactAssId: number | undefined, output: boolean | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/delete_contact_details?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (contactAssId === null)
            throw new Error("The parameter 'contactAssId' cannot be null.");
        else if (contactAssId !== undefined)
            url_ += "contactAssId=" + encodeURIComponent("" + contactAssId) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }
    details(firmId: number | undefined,contactId: number | undefined, contactAssId: number | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/Contact/get_contact_details_by_contactId?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (contactAssId === null)
            throw new Error("The parameter 'contactAssId' cannot be null.");
        else if (contactAssId !== undefined)
            url_ += "contactAssId=" + encodeURIComponent("" + contactAssId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContactId(_response);
        });
    }
      
    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: ContactDetailsObj | undefined , contactAssId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/save_contact_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param entityTypeID (optional) 
     * @param entityId (optional) 
     * @param firmId (optional) 
     * @return OK
     */
    details(entityTypeID: number | undefined, entityId: number | undefined, firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ParentEntity/get_regulator_contact_details?";
        if (entityTypeID === null)
            throw new Error("The parameter 'entityTypeID' cannot be null.");
        else if (entityTypeID !== undefined)
            url_ += "entityTypeID=" + encodeURIComponent("" + entityTypeID) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ByClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param contactId (optional) 
     * @param contactAssId (optional) 
     * @return OK
     */
    contactId(firmId: number | undefined, contactId: number | undefined, contactAssId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_contact_details_by_contactId?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (contactAssId === null)
            throw new Error("The parameter 'contactAssId' cannot be null.");
        else if (contactAssId !== undefined)
            url_ += "contactAssId=" + encodeURIComponent("" + contactAssId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContactId(_response);
        });
    }

    protected processContactId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    firmId(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_entity_types_by_firmId?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFirmId(_response);
        });
    }

    protected processFirmId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param contactId (optional) 
     * @param functionTypeId (optional) 
     * @return OK
     */
    functionTypeId(firmId: number | undefined, contactId: number | undefined, functionTypeId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_contact_by_functionTypeId?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (functionTypeId === null)
            throw new Error("The parameter 'functionTypeId' cannot be null.");
        else if (functionTypeId !== undefined)
            url_ += "functionTypeId=" + encodeURIComponent("" + functionTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFunctionTypeId(_response);
        });
    }

    protected processFunctionTypeId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param qFCNum (optional) 
     * @return OK
     */
    qfcnum(qFCNum: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_details_by_qfcnum?";
        if (qFCNum === null)
            throw new Error("The parameter 'qFCNum' cannot be null.");
        else if (qFCNum !== undefined)
            url_ += "QFCNum=" + encodeURIComponent("" + qFCNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQfcnum(_response);
        });
    }

    protected processQfcnum(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param countryId (optional) 
     * @param firmId (optional) 
     * @return OK
     */
    country(countryId: number | undefined, firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ParentEntity/get_regulators_by_country?";
        if (countryId === null)
            throw new Error("The parameter 'countryId' cannot be null.");
        else if (countryId !== undefined)
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountry(_response);
        });
    }

    protected processCountry(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    user(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/get_tasks_assigned_by_user?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param objectActItmID (optional) 
     * @return OK
     */
    objectItm(objectActItmID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/get_personal_remider_by_objectItm?";
        if (objectActItmID === null)
            throw new Error("The parameter 'objectActItmID' cannot be null.");
        else if (objectActItmID !== undefined)
            url_ += "ObjectActItmID=" + encodeURIComponent("" + objectActItmID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processObjectItm(_response);
        });
    }

    protected processObjectItm(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    parent(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/get_users_hierarchy_by_parent?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParent(_response);
        });
    }

    protected processParent(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    userId(userId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/get_username_by_userId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserId(_response);
        });
    }

    protected processUserId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param depId (optional) 
     * @return OK
     */
    departmentId(depId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/get_users_by_departmentId?";
        if (depId === null)
            throw new Error("The parameter 'depId' cannot be null.");
        else if (depId !== undefined)
            url_ += "depId=" + encodeURIComponent("" + depId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDepartmentId(_response);
        });
    }

    protected processDepartmentId(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param roleId (optional) 
     * @return OK
     */
    roleId(roleId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/get_users_by_roleId?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoleId(_response);
        });
    }

    protected processRoleId(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class PopulateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    ais(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_populate_ais?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAis(_response);
        });
    }

    protected processAis(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ControllerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param functionTypeId (optional) 
     * @param contactId (optional) 
     * @param contactAssId (optional) 
     * @return OK
     */
    details(firmId: number | undefined, functionTypeId: number | undefined, contactId: number | undefined, contactAssId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_individual_controller_details?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (functionTypeId === null)
            throw new Error("The parameter 'functionTypeId' cannot be null.");
        else if (functionTypeId !== undefined)
            url_ += "functionTypeId=" + encodeURIComponent("" + functionTypeId) + "&";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (contactAssId === null)
            throw new Error("The parameter 'contactAssId' cannot be null.");
        else if (contactAssId !== undefined)
            url_ += "contactAssId=" + encodeURIComponent("" + contactAssId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class MainClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param contactAssnId (optional) 
     * @param entityTypeId (optional) 
     * @param entityId (optional) 
     * @param output (optional) 
     * @return OK
     */
    contact(firmId: number | undefined, contactAssnId: number | undefined, entityTypeId: number | undefined, entityId: number | undefined, output: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/is_main_contact?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (contactAssnId === null)
            throw new Error("The parameter 'contactAssnId' cannot be null.");
        else if (contactAssnId !== undefined)
            url_ += "contactAssnId=" + encodeURIComponent("" + contactAssnId) + "&";
        if (entityTypeId === null)
            throw new Error("The parameter 'entityTypeId' cannot be null.");
        else if (entityTypeId !== undefined)
            url_ += "EntityTypeId=" + encodeURIComponent("" + entityTypeId) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContact(_response);
        });
    }

    protected processContact(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class EmailClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param emailAddress (optional) 
     * @param contactAssId (optional) 
     * @return OK
     */
    unique(emailAddress: string | undefined, contactAssId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/is_email_unique?";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (contactAssId === null)
            throw new Error("The parameter 'contactAssId' cannot be null.");
        else if (contactAssId !== undefined)
            url_ += "contactAssId=" + encodeURIComponent("" + contactAssId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnique(_response);
        });
    }

    protected processUnique(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    details(docID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_document_email_details?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: InsertEmailObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/save_email_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    address(userId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/get_user_email_address?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddress(_response);
        });
    }

    protected processAddress(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class FunctionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    types(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_contact_function_types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param contactId (optional) 
     * @param contactAssId (optional) 
     * @return OK
     */
    list(contactId: number | undefined, contactAssId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_contact_function_list?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        if (contactAssId === null)
            throw new Error("The parameter 'contactAssId' cannot be null.");
        else if (contactAssId !== undefined)
            url_ += "contactAssId=" + encodeURIComponent("" + contactAssId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ActiveClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    contacts(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Contact/get_active_contacts?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContacts(_response);
        });
    }

    protected processContacts(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param roleId (optional) 
     * @return OK
     */
    user(userId: number | undefined, roleId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/is_active_user?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class FirmsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    dashboard(userId: number | undefined): Promise<DataTableResultListBaseResponse> {
        let url_ = this.baseUrl + "/api/Dashboard/get_rpt_firms_dashboard?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDashboard(_response);
        });
    }

    protected processDashboard(response: Response): Promise<DataTableResultListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataTableResultListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataTableResultListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param operationalStatusId (optional) 
     * @param authorisationCaseOfficerId (optional) 
     * @param supervisionCaseOfficerId (optional) 
     * @param qFCNumber (optional) 
     * @param userId (optional) 
     * @param relevantPerson (optional) 
     * @param cSVAuthorisationStatus (optional) 
     * @param cSVLicenseStatus (optional) 
     * @param cSVLegalStatus (optional) 
     * @param cSVPrudentialCategory (optional) 
     * @param cSVSectorTypes (optional) 
     * @param cSVFirmTypes (optional) 
     * @param cSVFirmStatus (optional) 
     * @param cSVSupCategories (optional) 
     * @param cSVAuthorisationCategories (optional) 
     * @param objectID (optional) 
     * @return OK
     */
    list(firmId: number | undefined, operationalStatusId: number | undefined, authorisationCaseOfficerId: number | undefined, supervisionCaseOfficerId: number | undefined, qFCNumber: string | undefined, userId: number | undefined, relevantPerson: number | undefined, cSVAuthorisationStatus: string | undefined, cSVLicenseStatus: string | undefined, cSVLegalStatus: string | undefined, cSVPrudentialCategory: string | undefined, cSVSectorTypes: string | undefined, cSVFirmTypes: string | undefined, cSVFirmStatus: string | undefined, cSVSupCategories: string | undefined, cSVAuthorisationCategories: string | undefined, objectID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firms_list?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (operationalStatusId === null)
            throw new Error("The parameter 'operationalStatusId' cannot be null.");
        else if (operationalStatusId !== undefined)
            url_ += "OperationalStatusId=" + encodeURIComponent("" + operationalStatusId) + "&";
        if (authorisationCaseOfficerId === null)
            throw new Error("The parameter 'authorisationCaseOfficerId' cannot be null.");
        else if (authorisationCaseOfficerId !== undefined)
            url_ += "AuthorisationCaseOfficerId=" + encodeURIComponent("" + authorisationCaseOfficerId) + "&";
        if (supervisionCaseOfficerId === null)
            throw new Error("The parameter 'supervisionCaseOfficerId' cannot be null.");
        else if (supervisionCaseOfficerId !== undefined)
            url_ += "SupervisionCaseOfficerId=" + encodeURIComponent("" + supervisionCaseOfficerId) + "&";
        if (qFCNumber === null)
            throw new Error("The parameter 'qFCNumber' cannot be null.");
        else if (qFCNumber !== undefined)
            url_ += "QFCNumber=" + encodeURIComponent("" + qFCNumber) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (relevantPerson === null)
            throw new Error("The parameter 'relevantPerson' cannot be null.");
        else if (relevantPerson !== undefined)
            url_ += "RelevantPerson=" + encodeURIComponent("" + relevantPerson) + "&";
        if (cSVAuthorisationStatus === null)
            throw new Error("The parameter 'cSVAuthorisationStatus' cannot be null.");
        else if (cSVAuthorisationStatus !== undefined)
            url_ += "CSVAuthorisationStatus=" + encodeURIComponent("" + cSVAuthorisationStatus) + "&";
        if (cSVLicenseStatus === null)
            throw new Error("The parameter 'cSVLicenseStatus' cannot be null.");
        else if (cSVLicenseStatus !== undefined)
            url_ += "CSVLicenseStatus=" + encodeURIComponent("" + cSVLicenseStatus) + "&";
        if (cSVLegalStatus === null)
            throw new Error("The parameter 'cSVLegalStatus' cannot be null.");
        else if (cSVLegalStatus !== undefined)
            url_ += "CSVLegalStatus=" + encodeURIComponent("" + cSVLegalStatus) + "&";
        if (cSVPrudentialCategory === null)
            throw new Error("The parameter 'cSVPrudentialCategory' cannot be null.");
        else if (cSVPrudentialCategory !== undefined)
            url_ += "CSVPrudentialCategory=" + encodeURIComponent("" + cSVPrudentialCategory) + "&";
        if (cSVSectorTypes === null)
            throw new Error("The parameter 'cSVSectorTypes' cannot be null.");
        else if (cSVSectorTypes !== undefined)
            url_ += "CSVSectorTypes=" + encodeURIComponent("" + cSVSectorTypes) + "&";
        if (cSVFirmTypes === null)
            throw new Error("The parameter 'cSVFirmTypes' cannot be null.");
        else if (cSVFirmTypes !== undefined)
            url_ += "CSVFirmTypes=" + encodeURIComponent("" + cSVFirmTypes) + "&";
        if (cSVFirmStatus === null)
            throw new Error("The parameter 'cSVFirmStatus' cannot be null.");
        else if (cSVFirmStatus !== undefined)
            url_ += "CSVFirmStatus=" + encodeURIComponent("" + cSVFirmStatus) + "&";
        if (cSVSupCategories === null)
            throw new Error("The parameter 'cSVSupCategories' cannot be null.");
        else if (cSVSupCategories !== undefined)
            url_ += "CSVSupCategories=" + encodeURIComponent("" + cSVSupCategories) + "&";
        if (cSVAuthorisationCategories === null)
            throw new Error("The parameter 'cSVAuthorisationCategories' cannot be null.");
        else if (cSVAuthorisationCategories !== undefined)
            url_ += "CSVAuthorisationCategories=" + encodeURIComponent("" + cSVAuthorisationCategories) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "ObjectID=" + encodeURIComponent("" + objectID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    alphabetically(body: FirmsAlphabeticallyObj | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firms_alphabetically";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAlphabetically(_response);
        });
    }

    protected processAlphabetically(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class LocationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    list(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/FirmCapital/get_firm_capital_location_list?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    data(body: FirmCapitalObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/FirmCapital/insert_update_firm_capital_location_data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class CapitalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmCapLocId (optional) 
     * @param output (optional) 
     * @return OK
     */
    location(firmCapLocId: number | undefined, output: boolean | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/FirmCapital/delete_firm_capital_location?";
        if (firmCapLocId === null)
            throw new Error("The parameter 'firmCapLocId' cannot be null.");
        else if (firmCapLocId !== undefined)
            url_ += "firmCapLocId=" + encodeURIComponent("" + firmCapLocId) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLocation(_response);
        });
    }

    protected processLocation(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class CustomClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param procedureName (optional) 
     * @return OK
     */
    model(procedureName: string | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/generate_custom_model?";
        if (procedureName === null)
            throw new Error("The parameter 'procedureName' cannot be null.");
        else if (procedureName !== undefined)
            url_ += "procedureName=" + encodeURIComponent("" + procedureName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModel(_response);
        });
    }

    protected processModel(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param procedureName (optional) 
     * @return OK
     */
    param(procedureName: string | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/generate_custom_param?";
        if (procedureName === null)
            throw new Error("The parameter 'procedureName' cannot be null.");
        else if (procedureName !== undefined)
            url_ += "procedureName=" + encodeURIComponent("" + procedureName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParam(_response);
        });
    }

    protected processParam(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class AssignClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    firms(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_assign_firms?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFirms(_response);
        });
    }

    protected processFirms(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class HeaderClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param roleId (optional) 
     * @param objectOptType (optional) 
     * @return OK
     */
    details(firmId: number | undefined, roleId: number | undefined, objectOptType: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_header_details?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (objectOptType === null)
            throw new Error("The parameter 'objectOptType' cannot be null.");
        else if (objectOptType !== undefined)
            url_ += "objectOptType=" + encodeURIComponent("" + objectOptType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param firmRMPID (optional) 
     * @return OK
     */
    details(firmId: number | undefined, firmRMPID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_rmp_header_details?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmRMPID === null)
            throw new Error("The parameter 'firmRMPID' cannot be null.");
        else if (firmRMPID !== undefined)
            url_ += "firmRMPID=" + encodeURIComponent("" + firmRMPID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ClientClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    classification(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_client_classification?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassification(_response);
        });
    }

    protected processClassification(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class CategoryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param classificationID (optional) 
     * @param firmId (optional) 
     * @return OK
     */
    details(classificationID: number | undefined, firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_sup_category_details?";
        if (classificationID === null)
            throw new Error("The parameter 'classificationID' cannot be null.");
        else if (classificationID !== undefined)
            url_ += "classificationID=" + encodeURIComponent("" + classificationID) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    data(body: FirmClassificationObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/insert_update_sup_category_data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class PrtClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    basis(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_prt_basis?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBasis(_response);
        });
    }

    protected processBasis(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class LevelClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    users(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_assign_level_users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ExistingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param roleId (optional) 
     * @return OK
     */
    role(firmId: number | undefined, roleId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_existing_role?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRole(_response);
        });
    }

    protected processRole(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param qfcNum (optional) 
     * @param firmId (optional) 
     * @return OK
     */
    qfc(qfcNum: string | undefined, firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_existing_qfc?";
        if (qfcNum === null)
            throw new Error("The parameter 'qfcNum' cannot be null.");
        else if (qfcNum !== undefined)
            url_ += "qfcNum=" + encodeURIComponent("" + qfcNum) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQfc(_response);
        });
    }

    protected processQfc(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class DetailsByClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param qfcNum (optional) 
     * @return OK
     */
    qfc(qfcNum: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_details-by_qfc?";
        if (qfcNum === null)
            throw new Error("The parameter 'qfcNum' cannot be null.");
        else if (qfcNum !== undefined)
            url_ += "qfcNum=" + encodeURIComponent("" + qfcNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQfc(_response);
        });
    }

    protected processQfc(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class YearClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param flag (optional) 
     * @return OK
     */
    history(firmId: number | undefined, flag: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firms_end_year_history?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (flag === null)
            throw new Error("The parameter 'flag' cannot be null.");
        else if (flag !== undefined)
            url_ += "flag=" + encodeURIComponent("" + flag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    end(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_financial_year_end?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnd(_response);
        });
    }

    protected processEnd(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class NameClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    history(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firms_name_history?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ServiceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param qfcNum (optional) 
     * @param applTypeId (optional) 
     * @return OK
     */
    details(qfcNum: string | undefined, applTypeId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_service_details?";
        if (qfcNum === null)
            throw new Error("The parameter 'qfcNum' cannot be null.");
        else if (qfcNum !== undefined)
            url_ += "qfcNum=" + encodeURIComponent("" + qfcNum) + "&";
        if (applTypeId === null)
            throw new Error("The parameter 'applTypeId' cannot be null.");
        else if (applTypeId !== undefined)
            url_ += "applTypeId=" + encodeURIComponent("" + applTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ItemClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmRptSchItemID (optional) 
     * @return OK
     */
    id(firmRptSchItemID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_firm_rpt_period_by_rpt_sch_item_id?";
        if (firmRptSchItemID === null)
            throw new Error("The parameter 'firmRptSchItemID' cannot be null.");
        else if (firmRptSchItemID !== undefined)
            url_ += "firmRptSchItemID=" + encodeURIComponent("" + firmRptSchItemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processId(_response);
        });
    }

    protected processId(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmRiskActionItemID (optional) 
     * @return OK
     */
    history(firmRiskActionItemID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_risk_action_item_history?";
        if (firmRiskActionItemID === null)
            throw new Error("The parameter 'firmRiskActionItemID' cannot be null.");
        else if (firmRiskActionItemID !== undefined)
            url_ += "firmRiskActionItemID=" + encodeURIComponent("" + firmRiskActionItemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class AdditionalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param rptPeriodFromDate (optional) 
     * @param rptPeriodToDate (optional) 
     * @return OK
     */
    content(firmId: number | undefined, rptPeriodFromDate: string | undefined, rptPeriodToDate: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_additional_content?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (rptPeriodFromDate === null)
            throw new Error("The parameter 'rptPeriodFromDate' cannot be null.");
        else if (rptPeriodFromDate !== undefined)
            url_ += "rptPeriodFromDate=" + encodeURIComponent("" + rptPeriodFromDate) + "&";
        if (rptPeriodToDate === null)
            throw new Error("The parameter 'rptPeriodToDate' cannot be null.");
        else if (rptPeriodToDate !== undefined)
            url_ += "rptPeriodToDate=" + encodeURIComponent("" + rptPeriodToDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContent(_response);
        });
    }

    protected processContent(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param docTypeID (optional) 
     * @param rptPeriodTypeID (optional) 
     * @param rptPeriodFromDate (optional) 
     * @param rptPeriodToDate (optional) 
     * @param rptDueDate (optional) 
     * @return OK
     */
    schedules(docTypeID: number | undefined, rptPeriodTypeID: number | undefined, rptPeriodFromDate: string | undefined, rptPeriodToDate: string | undefined, rptDueDate: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_report_name_for_additional_schedules?";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        if (rptPeriodTypeID === null)
            throw new Error("The parameter 'rptPeriodTypeID' cannot be null.");
        else if (rptPeriodTypeID !== undefined)
            url_ += "rptPeriodTypeID=" + encodeURIComponent("" + rptPeriodTypeID) + "&";
        if (rptPeriodFromDate === null)
            throw new Error("The parameter 'rptPeriodFromDate' cannot be null.");
        else if (rptPeriodFromDate !== undefined)
            url_ += "rptPeriodFromDate=" + encodeURIComponent("" + rptPeriodFromDate) + "&";
        if (rptPeriodToDate === null)
            throw new Error("The parameter 'rptPeriodToDate' cannot be null.");
        else if (rptPeriodToDate !== undefined)
            url_ += "rptPeriodToDate=" + encodeURIComponent("" + rptPeriodToDate) + "&";
        if (rptDueDate === null)
            throw new Error("The parameter 'rptDueDate' cannot be null.");
        else if (rptDueDate !== undefined)
            url_ += "rptDueDate=" + encodeURIComponent("" + rptDueDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSchedules(_response);
        });
    }

    protected processSchedules(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class FeeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    params(body: InsertFirmRptAdminFee | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/insert_firm_rpt_admin_fee_params";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParams(_response);
        });
    }

    protected processParams(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param firmRptFeeID (optional) 
     * @param firmRptSchItemId (optional) 
     * @param firmRptReviewItemId (optional) 
     * @return OK
     */
    list(firmId: number | undefined, firmRptFeeID: number | undefined, firmRptSchItemId: number | undefined, firmRptReviewItemId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_admin_fee_list?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmRptFeeID === null)
            throw new Error("The parameter 'firmRptFeeID' cannot be null.");
        else if (firmRptFeeID !== undefined)
            url_ += "firmRptFeeID=" + encodeURIComponent("" + firmRptFeeID) + "&";
        if (firmRptSchItemId === null)
            throw new Error("The parameter 'firmRptSchItemId' cannot be null.");
        else if (firmRptSchItemId !== undefined)
            url_ += "firmRptSchItemId=" + encodeURIComponent("" + firmRptSchItemId) + "&";
        if (firmRptReviewItemId === null)
            throw new Error("The parameter 'firmRptReviewItemId' cannot be null.");
        else if (firmRptReviewItemId !== undefined)
            url_ += "firmRptReviewItemId=" + encodeURIComponent("" + firmRptReviewItemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class RecClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(body: UpdateAdminFeeObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/update_admin_fee_rec_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class RptClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmRptSignatoryID (optional) 
     * @param firmId (optional) 
     * @return OK
     */
    signatory(firmRptSignatoryID: number | undefined, firmId: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/delete_rpt_signatory?";
        if (firmRptSignatoryID === null)
            throw new Error("The parameter 'firmRptSignatoryID' cannot be null.");
        else if (firmRptSignatoryID !== undefined)
            url_ += "FirmRptSignatoryID=" + encodeURIComponent("" + firmRptSignatoryID) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignatory(_response);
        });
    }

    protected processSignatory(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    signatory(body: InsertRptSignObj | undefined): Promise<Int32BaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/insert_rpt_signatory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignatory(_response);
        });
    }

    protected processSignatory(response: Response): Promise<Int32BaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32BaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Int32BaseResponse>(null as any);
    }
}

export class OperationalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    data(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/get_operational_data?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class IncorporationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmApplStatusTypeID (optional) 
     * @return OK
     */
    required(firmApplStatusTypeID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_date_of_incorporation_required?";
        if (firmApplStatusTypeID === null)
            throw new Error("The parameter 'firmApplStatusTypeID' cannot be null.");
        else if (firmApplStatusTypeID !== undefined)
            url_ += "firmApplStatusTypeID=" + encodeURIComponent("" + firmApplStatusTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequired(_response);
        });
    }

    protected processRequired(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ForClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    waivers(firmId: number | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_firm_authorised_for_waivers?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWaivers(_response);
        });
    }

    protected processWaivers(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @param objectInstanceRevNum (optional) 
     * @return OK
     */
    wf(objectID: number | undefined, objectInstanceID: number | undefined, objectInstanceRevNum: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/validate_object_for_wf?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "objectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWf(_response);
        });
    }

    protected processWf(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class TheClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    firm(firmId: number | undefined, userId: number | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_user_supervisor_for_the_firm?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFirm(_response);
        });
    }

    protected processFirm(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }
}

export class RoleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param role (optional) 
     * @return OK
     */
    exist(firmId: number | undefined, role: number | undefined): Promise<BooleanBaseResponse> {
        let url_ = this.baseUrl + "/api/Firms/is_role_exist?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExist(_response);
        });
    }

    protected processExist(response: Response): Promise<BooleanBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param objectId (optional) 
     * @param objectOpTypeId (optional) 
     * @param instanceWFStatus (optional) 
     * @param objectInstanceId (optional) 
     * @param objectInstanceRevNo (optional) 
     * @return OK
     */
    access(userId: number | undefined, objectId: number | undefined, objectOpTypeId: number | undefined, instanceWFStatus: number | undefined, objectInstanceId: number | undefined, objectInstanceRevNo: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Security/get_app_role_access?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (objectId === null)
            throw new Error("The parameter 'objectId' cannot be null.");
        else if (objectId !== undefined)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (objectOpTypeId === null)
            throw new Error("The parameter 'objectOpTypeId' cannot be null.");
        else if (objectOpTypeId !== undefined)
            url_ += "objectOpTypeId=" + encodeURIComponent("" + objectOpTypeId) + "&";
        if (instanceWFStatus === null)
            throw new Error("The parameter 'instanceWFStatus' cannot be null.");
        else if (instanceWFStatus !== undefined)
            url_ += "instanceWFStatus=" + encodeURIComponent("" + instanceWFStatus) + "&";
        if (objectInstanceId === null)
            throw new Error("The parameter 'objectInstanceId' cannot be null.");
        else if (objectInstanceId !== undefined)
            url_ += "objectInstanceId=" + encodeURIComponent("" + objectInstanceId) + "&";
        if (objectInstanceRevNo === null)
            throw new Error("The parameter 'objectInstanceRevNo' cannot be null.");
        else if (objectInstanceRevNo !== undefined)
            url_ += "objectInstanceRevNo=" + encodeURIComponent("" + objectInstanceRevNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccess(_response);
        });
    }

    protected processAccess(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class SubjectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    types(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Journal/get_supervision_journal_subject_types?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ApprovedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    individuals(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Journal/get_all_approved_individuals?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIndividuals(_response);
        });
    }

    protected processIndividuals(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class JournalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    data(body: InsertJournalObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Journal/save_sup_journal_data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    supervision(body: InsertSupervisionObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Journal/inser_update_journal_supervision";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupervision(_response);
        });
    }

    protected processSupervision(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param journalSubjectAssnID (optional) 
     * @param supervisionJournalID (optional) 
     * @return OK
     */
    subject(journalSubjectAssnID: string | undefined, supervisionJournalID: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Journal/delete_journal_subject?";
        if (journalSubjectAssnID === null)
            throw new Error("The parameter 'journalSubjectAssnID' cannot be null.");
        else if (journalSubjectAssnID !== undefined)
            url_ += "JournalSubjectAssnID=" + encodeURIComponent("" + journalSubjectAssnID) + "&";
        if (supervisionJournalID === null)
            throw new Error("The parameter 'supervisionJournalID' cannot be null.");
        else if (supervisionJournalID !== undefined)
            url_ += "SupervisionJournalID=" + encodeURIComponent("" + supervisionJournalID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubject(_response);
        });
    }

    protected processSubject(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class DocumentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    details(docID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_document_details?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    attributes(docID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_document_attributes?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAttributes(_response);
        });
    }

    protected processAttributes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    recipients(docID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_document_recipients?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecipients(_response);
        });
    }

    protected processRecipients(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    md(docID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_document_md?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMd(_response);
        });
    }

    protected processMd(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    details(docID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/delete_document_details?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param docCategoryTypeID (optional) 
     * @return OK
     */
    type(docCategoryTypeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_document_type?";
        if (docCategoryTypeID === null)
            throw new Error("The parameter 'docCategoryTypeID' cannot be null.");
        else if (docCategoryTypeID !== undefined)
            url_ += "docCategoryTypeID=" + encodeURIComponent("" + docCategoryTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param docTypeId (optional) 
     * @param usageTypeId (optional) 
     * @return OK
     */
    type2(docTypeId: number | undefined, usageTypeId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/get_document_type?";
        if (docTypeId === null)
            throw new Error("The parameter 'docTypeId' cannot be null.");
        else if (docTypeId !== undefined)
            url_ += "docTypeId=" + encodeURIComponent("" + docTypeId) + "&";
        if (usageTypeId === null)
            throw new Error("The parameter 'usageTypeId' cannot be null.");
        else if (usageTypeId !== undefined)
            url_ += "usageTypeId=" + encodeURIComponent("" + usageTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType2(_response);
        });
    }

    protected processType2(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class RecipientsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    methods(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_document_recipients_methods";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMethods(_response);
        });
    }

    protected processMethods(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class FilesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param refNo (optional) 
     * @param fileNo (optional) 
     * @return OK
     */
    list(refNo: string | undefined, fileNo: string | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_files_list?";
        if (refNo === null)
            throw new Error("The parameter 'refNo' cannot be null.");
        else if (refNo !== undefined)
            url_ += "refNo=" + encodeURIComponent("" + refNo) + "&";
        if (fileNo === null)
            throw new Error("The parameter 'fileNo' cannot be null.");
        else if (fileNo !== undefined)
            url_ += "fileNo=" + encodeURIComponent("" + fileNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class MdClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param docTypeID (optional) 
     * @return OK
     */
    type(docTypeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_md_type?";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ListClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param docMDDefID (optional) 
     * @return OK
     */
    values(docMDDefID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_md_list_values?";
        if (docMDDefID === null)
            throw new Error("The parameter 'docMDDefID' cannot be null.");
        else if (docMDDefID !== undefined)
            url_ += "docMDDefID=" + encodeURIComponent("" + docMDDefID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValues(_response);
        });
    }

    protected processValues(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param relatedEntityTypeID (optional) 
     * @param otherEntityID (optional) 
     * @return OK
     */
    search(firmId: number | undefined, relatedEntityTypeID: number | undefined, otherEntityID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ParentEntity/get_parent_entity_list_search?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (relatedEntityTypeID === null)
            throw new Error("The parameter 'relatedEntityTypeID' cannot be null.");
        else if (relatedEntityTypeID !== undefined)
            url_ += "relatedEntityTypeID=" + encodeURIComponent("" + relatedEntityTypeID) + "&";
        if (otherEntityID === null)
            throw new Error("The parameter 'otherEntityID' cannot be null.");
        else if (otherEntityID !== undefined)
            url_ += "otherEntityID=" + encodeURIComponent("" + otherEntityID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class SubClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param docType (optional) 
     * @return OK
     */
    types(docType: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_sub_types?";
        if (docType === null)
            throw new Error("The parameter 'docType' cannot be null.");
        else if (docType !== undefined)
            url_ += "docType=" + encodeURIComponent("" + docType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    types(body: DocSubTypeObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/save_doc_sub_types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @param docsubTypeID (optional) 
     * @return OK
     */
    type(docID: number | undefined, docsubTypeID: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/delete_doc_sub_type?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        if (docsubTypeID === null)
            throw new Error("The parameter 'docsubTypeID' cannot be null.");
        else if (docsubTypeID !== undefined)
            url_ += "docsubTypeID=" + encodeURIComponent("" + docsubTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param docTypeId (optional) 
     * @return OK
     */
    types(docTypeId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReturnView/get_reports_received_doc_sub_types?";
        if (docTypeId === null)
            throw new Error("The parameter 'docTypeId' cannot be null.");
        else if (docTypeId !== undefined)
            url_ += "docTypeId=" + encodeURIComponent("" + docTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class DocClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param docTypeID (optional) 
     * @param objectID (optional) 
     * @return OK
     */
    type(firmId: number | undefined, docTypeID: number | undefined, objectID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_list_by_firm_doc_type?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    md(docID: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/delete_doc_md?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMd(_response);
        });
    }

    protected processMd(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param docTypeId (optional) 
     * @return OK
     */
    name(docTypeId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_name?";
        if (docTypeId === null)
            throw new Error("The parameter 'docTypeId' cannot be null.");
        else if (docTypeId !== undefined)
            url_ += "docTypeId=" + encodeURIComponent("" + docTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processName(_response);
        });
    }

    protected processName(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    referenced(docID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/is_doc_referenced?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReferenced(_response);
        });
    }

    protected processReferenced(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param objectName (optional) 
     * @return OK
     */
    type(objectName: string | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_type?";
        if (objectName === null)
            throw new Error("The parameter 'objectName' cannot be null.");
        else if (objectName !== undefined)
            url_ += "objectName=" + encodeURIComponent("" + objectName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processType(_response);
        });
    }

    protected processType(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param docTypes (optional) 
     * @param docSubTypes (optional) 
     * @return OK
     */
    list(firmId: number | undefined, docTypes: string | undefined, docSubTypes: string | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_doc_list?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (docTypes === null)
            throw new Error("The parameter 'docTypes' cannot be null.");
        else if (docTypes !== undefined)
            url_ += "docTypes=" + encodeURIComponent("" + docTypes) + "&";
        if (docSubTypes === null)
            throw new Error("The parameter 'docSubTypes' cannot be null.");
        else if (docSubTypes !== undefined)
            url_ += "docSubTypes=" + encodeURIComponent("" + docSubTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ReferenceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param docTypeID (optional) 
     * @param receivedDate (optional) 
     * @return OK
     */
    number(docTypeID: number | undefined, receivedDate: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_new_reference_number?";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        if (receivedDate === null)
            throw new Error("The parameter 'receivedDate' cannot be null.");
        else if (receivedDate !== undefined)
            url_ += "receivedDate=" + encodeURIComponent("" + receivedDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNumber(_response);
        });
    }

    protected processNumber(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class FileClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param receivedDate (optional) 
     * @return OK
     */
    number(firmId: number | undefined, receivedDate: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_new_file_number?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (receivedDate === null)
            throw new Error("The parameter 'receivedDate' cannot be null.");
        else if (receivedDate !== undefined)
            url_ += "receivedDate=" + encodeURIComponent("" + receivedDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNumber(_response);
        });
    }

    protected processNumber(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param fileLoc (optional) 
     * @return OK
     */
    exists(fileLoc: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/is_file_exists?";
        if (fileLoc === null)
            throw new Error("The parameter 'fileLoc' cannot be null.");
        else if (fileLoc !== undefined)
            url_ += "fileLoc=" + encodeURIComponent("" + fileLoc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExists(_response);
        });
    }

    protected processExists(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class EditClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param docID (optional) 
     * @return OK
     */
    mode(docID: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/delete_doc_subtypes_in_edit_mode?";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMode(_response);
        });
    }

    protected processMode(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class RaClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param docTypeID (optional) 
     * @return OK
     */
    affiliates(docTypeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_default_users_and_ra_affiliates?";
        if (docTypeID === null)
            throw new Error("The parameter 'docTypeID' cannot be null.");
        else if (docTypeID !== undefined)
            url_ += "docTypeID=" + encodeURIComponent("" + docTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAffiliates(_response);
        });
    }

    protected processAffiliates(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class RecipientClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: RecipientObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/save_recipient_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ContextClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: DocMdObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/save_document_context_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class MessageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param messageKey (optional) 
     * @return OK
     */
    property(messageKey: string | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_message_property?";
        if (messageKey === null)
            throw new Error("The parameter 'messageKey' cannot be null.");
        else if (messageKey !== undefined)
            url_ += "messageKey=" + encodeURIComponent("" + messageKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProperty(_response);
        });
    }

    protected processProperty(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class PendingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    ais(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/get_pending_ais";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAis(_response);
        });
    }

    protected processAis(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class FormClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    object(body: InsertLogFormObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/LogForm/save_log_form_object";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processObject(_response);
        });
    }

    protected processObject(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class NoticeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    types(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/get_notice_types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param noticeTypeID (optional) 
     * @return OK
     */
    templates(noticeTypeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/get_notice_templates?";
        if (noticeTypeID === null)
            throw new Error("The parameter 'noticeTypeID' cannot be null.");
        else if (noticeTypeID !== undefined)
            url_ += "noticeTypeID=" + encodeURIComponent("" + noticeTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemplates(_response);
        });
    }

    protected processTemplates(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param noticeID (optional) 
     * @return OK
     */
    details(noticeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/validate_notice_details?";
        if (noticeID === null)
            throw new Error("The parameter 'noticeID' cannot be null.");
        else if (noticeID !== undefined)
            url_ += "noticeID=" + encodeURIComponent("" + noticeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @return OK
     */
    templates(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/get_admin_notice_templates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemplates(_response);
        });
    }

    protected processTemplates(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: UpdateNoticeDetailsObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/insert_update_notice_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    questionnaire(body: NoticeQuestionaireObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/insert_update_notice_questionnaire";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuestionnaire(_response);
        });
    }

    protected processQuestionnaire(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    questionnaire(body: NoticeQuestionaireObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/update_notice_questionnaire";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuestionnaire(_response);
        });
    }

    protected processQuestionnaire(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class OperatorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    types(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/get_evaluation_operator_types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ResponseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param firmNoticeID (optional) 
     * @return OK
     */
    details(firmId: number | undefined, firmNoticeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/get_firm_notice_response_details?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmNoticeID === null)
            throw new Error("The parameter 'firmNoticeID' cannot be null.");
        else if (firmNoticeID !== undefined)
            url_ += "firmNoticeID=" + encodeURIComponent("" + firmNoticeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class TemplateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param noticeTemplateID (optional) 
     * @return OK
     */
    details(noticeTemplateID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/validate_notice_template_details?";
        if (noticeTemplateID === null)
            throw new Error("The parameter 'noticeTemplateID' cannot be null.");
        else if (noticeTemplateID !== undefined)
            url_ += "noticeTemplateID=" + encodeURIComponent("" + noticeTemplateID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: NoticeTemplatesObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/insert_update_notice_template_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    questionnaire(body: NoticeTemplateQuestionaireObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/insert_update_notice_template_questionnaire";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuestionnaire(_response);
        });
    }

    protected processQuestionnaire(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class QuestionnaireClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    items(body: NoticeQuestionaireItemsObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/insert_update_notice_questionnaire_items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItems(_response);
        });
    }

    protected processItems(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    items(body: NoticeTemplateQuestionaireItemsObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/insert_update_notice_template_questionnaire_items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItems(_response);
        });
    }

    protected processItems(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class EvaluationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    criteria(body: NoticCriteriaObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/insert_update_notice_response_evaluation_criteria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCriteria(_response);
        });
    }

    protected processCriteria(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    criteria(body: NoticeTemplateResponseCriteriaObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/insert_update_notice_template_response_evaluation_criteria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCriteria(_response);
        });
    }

    protected processCriteria(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class AndClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param noticeID (optional) 
     * @param noticeQuestionnaireID (optional) 
     * @param noticeQuestionnaireItemID (optional) 
     * @param noticeResponseEvaluationCriteriaID (optional) 
     * @param deleteEvalutationCriteria (optional) 
     * @return OK
     */
    responses(noticeID: number | undefined, noticeQuestionnaireID: number | undefined, noticeQuestionnaireItemID: string | undefined, noticeResponseEvaluationCriteriaID: string | undefined, deleteEvalutationCriteria: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/delete_notice_questionnaire_and_responses?";
        if (noticeID === null)
            throw new Error("The parameter 'noticeID' cannot be null.");
        else if (noticeID !== undefined)
            url_ += "NoticeID=" + encodeURIComponent("" + noticeID) + "&";
        if (noticeQuestionnaireID === null)
            throw new Error("The parameter 'noticeQuestionnaireID' cannot be null.");
        else if (noticeQuestionnaireID !== undefined)
            url_ += "NoticeQuestionnaireID=" + encodeURIComponent("" + noticeQuestionnaireID) + "&";
        if (noticeQuestionnaireItemID === null)
            throw new Error("The parameter 'noticeQuestionnaireItemID' cannot be null.");
        else if (noticeQuestionnaireItemID !== undefined)
            url_ += "NoticeQuestionnaireItemID=" + encodeURIComponent("" + noticeQuestionnaireItemID) + "&";
        if (noticeResponseEvaluationCriteriaID === null)
            throw new Error("The parameter 'noticeResponseEvaluationCriteriaID' cannot be null.");
        else if (noticeResponseEvaluationCriteriaID !== undefined)
            url_ += "NoticeResponseEvaluationCriteriaID=" + encodeURIComponent("" + noticeResponseEvaluationCriteriaID) + "&";
        if (deleteEvalutationCriteria === null)
            throw new Error("The parameter 'deleteEvalutationCriteria' cannot be null.");
        else if (deleteEvalutationCriteria !== undefined)
            url_ += "DeleteEvalutationCriteria=" + encodeURIComponent("" + deleteEvalutationCriteria) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResponses(_response);
        });
    }

    protected processResponses(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param noticeTemplateID (optional) 
     * @param noticeTemplateQuestionnaireID (optional) 
     * @param noticeTemplateQuestionnaireItemID (optional) 
     * @param noticeTemplateResponseEvaluationCriteriaID (optional) 
     * @param deleteEvalutationCriteria (optional) 
     * @return OK
     */
    respones(noticeTemplateID: number | undefined, noticeTemplateQuestionnaireID: number | undefined, noticeTemplateQuestionnaireItemID: string | undefined, noticeTemplateResponseEvaluationCriteriaID: string | undefined, deleteEvalutationCriteria: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/delete_notice_template_questionnaire_and_respones?";
        if (noticeTemplateID === null)
            throw new Error("The parameter 'noticeTemplateID' cannot be null.");
        else if (noticeTemplateID !== undefined)
            url_ += "noticeTemplateID=" + encodeURIComponent("" + noticeTemplateID) + "&";
        if (noticeTemplateQuestionnaireID === null)
            throw new Error("The parameter 'noticeTemplateQuestionnaireID' cannot be null.");
        else if (noticeTemplateQuestionnaireID !== undefined)
            url_ += "NoticeTemplateQuestionnaireID=" + encodeURIComponent("" + noticeTemplateQuestionnaireID) + "&";
        if (noticeTemplateQuestionnaireItemID === null)
            throw new Error("The parameter 'noticeTemplateQuestionnaireItemID' cannot be null.");
        else if (noticeTemplateQuestionnaireItemID !== undefined)
            url_ += "NoticeTemplateQuestionnaireItemID=" + encodeURIComponent("" + noticeTemplateQuestionnaireItemID) + "&";
        if (noticeTemplateResponseEvaluationCriteriaID === null)
            throw new Error("The parameter 'noticeTemplateResponseEvaluationCriteriaID' cannot be null.");
        else if (noticeTemplateResponseEvaluationCriteriaID !== undefined)
            url_ += "NoticeTemplateResponseEvaluationCriteriaID=" + encodeURIComponent("" + noticeTemplateResponseEvaluationCriteriaID) + "&";
        if (deleteEvalutationCriteria === null)
            throw new Error("The parameter 'deleteEvalutationCriteria' cannot be null.");
        else if (deleteEvalutationCriteria !== undefined)
            url_ += "DeleteEvalutationCriteria=" + encodeURIComponent("" + deleteEvalutationCriteria) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRespones(_response);
        });
    }

    protected processRespones(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param objectWFStatusID (optional) 
     * @return OK
     */
    notifications(objectWFStatusID: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/delete_workflow_tasks_and_notifications?";
        if (objectWFStatusID === null)
            throw new Error("The parameter 'objectWFStatusID' cannot be null.");
        else if (objectWFStatusID !== undefined)
            url_ += "ObjectWFStatusID=" + encodeURIComponent("" + objectWFStatusID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications(_response);
        });
    }

    protected processNotifications(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class FinalizeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(body: UpdateNoticeFinalizeObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Notice/update_notice_finalize_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class WorkflowClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param objectWFTaskStatusID (optional) 
     * @return OK
     */
    task(objectWFTaskStatusID: number | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/delete_workflow_task?";
        if (objectWFTaskStatusID === null)
            throw new Error("The parameter 'objectWFTaskStatusID' cannot be null.");
        else if (objectWFTaskStatusID !== undefined)
            url_ += "objectWFTaskStatusID=" + encodeURIComponent("" + objectWFTaskStatusID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTask(_response);
        });
    }

    protected processTask(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class ObjectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @param objectInstanceRevNum (optional) 
     * @param objectWFStatusID (optional) 
     * @return OK
     */
    workflow(objectID: number | undefined, objectInstanceID: number | undefined, objectInstanceRevNum: number | undefined, objectWFStatusID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/get_object_workflow?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "objectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        if (objectWFStatusID === null)
            throw new Error("The parameter 'objectWFStatusID' cannot be null.");
        else if (objectWFStatusID !== undefined)
            url_ += "objectWFStatusID=" + encodeURIComponent("" + objectWFStatusID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWorkflow(_response);
        });
    }

    protected processWorkflow(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param objectInstanceID (optional) 
     * @param docID (optional) 
     * @return OK
     */
    signatories(objectInstanceID: number | undefined, docID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_object_signatories?";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (docID === null)
            throw new Error("The parameter 'docID' cannot be null.");
        else if (docID !== undefined)
            url_ += "docID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignatories(_response);
        });
    }

    protected processSignatories(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @param objectInstanceRevNum (optional) 
     * @return OK
     */
    details(objectID: number | undefined, objectInstanceID: number | undefined, objectInstanceRevNum: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/get_my_task_by_object_details?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "ObjectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "ObjectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "ObjectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class CancelClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param objectWFStatusID (optional) 
     * @param objectTaskTypeID (optional) 
     * @return OK
     */
    workflow(objectWFStatusID: number | undefined, objectTaskTypeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/get_emails_to_notify_on_cancel_workflow?";
        if (objectWFStatusID === null)
            throw new Error("The parameter 'objectWFStatusID' cannot be null.");
        else if (objectWFStatusID !== undefined)
            url_ += "objectWFStatusID=" + encodeURIComponent("" + objectWFStatusID) + "&";
        if (objectTaskTypeID === null)
            throw new Error("The parameter 'objectTaskTypeID' cannot be null.");
        else if (objectTaskTypeID !== undefined)
            url_ += "objectTaskTypeID=" + encodeURIComponent("" + objectTaskTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWorkflow(_response);
        });
    }

    protected processWorkflow(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class TaskClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param roleId (optional) 
     * @param objectOpTypeId (optional) 
     * @return OK
     */
    types(roleId: number | undefined, objectOpTypeId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/get_workflow_task_types?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (objectOpTypeId === null)
            throw new Error("The parameter 'objectOpTypeId' cannot be null.");
        else if (objectOpTypeId !== undefined)
            url_ += "objectOpTypeId=" + encodeURIComponent("" + objectOpTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param objectTaskTypeID (optional) 
     * @param objectID (optional) 
     * @param notificationFlag (optional) 
     * @param objectWFTaskDefID (optional) 
     * @return OK
     */
    roles(objectTaskTypeID: number | undefined, objectID: number | undefined, notificationFlag: number | undefined, objectWFTaskDefID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/get_workflow_task_roles?";
        if (objectTaskTypeID === null)
            throw new Error("The parameter 'objectTaskTypeID' cannot be null.");
        else if (objectTaskTypeID !== undefined)
            url_ += "objectTaskTypeID=" + encodeURIComponent("" + objectTaskTypeID) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (notificationFlag === null)
            throw new Error("The parameter 'notificationFlag' cannot be null.");
        else if (notificationFlag !== undefined)
            url_ += "notificationFlag=" + encodeURIComponent("" + notificationFlag) + "&";
        if (objectWFTaskDefID === null)
            throw new Error("The parameter 'objectWFTaskDefID' cannot be null.");
        else if (objectWFTaskDefID !== undefined)
            url_ += "objectWFTaskDefID=" + encodeURIComponent("" + objectWFTaskDefID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoles(_response);
        });
    }

    protected processRoles(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(body: UpdateStatusObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/update_wf_task_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(body: InstertTasksObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/insert_update_workflow_task_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(body: ObjectReviewObj | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/ObjectWF/update_object_wf_task_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    list(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/get_my_task_list?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class WfClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    tasks(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/get_pending_wf_tasks?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTasks(_response);
        });
    }

    protected processTasks(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param objectID (optional) 
     * @param objectInstanceID (optional) 
     * @param objectInstanceRevNum (optional) 
     * @return OK
     */
    instance(objectID: number | undefined, objectInstanceID: number | undefined, objectInstanceRevNum: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/check_wf_instance?";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        if (objectInstanceRevNum === null)
            throw new Error("The parameter 'objectInstanceRevNum' cannot be null.");
        else if (objectInstanceRevNum !== undefined)
            url_ += "objectInstanceRevNum=" + encodeURIComponent("" + objectInstanceRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstance(_response);
        });
    }

    protected processInstance(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(body: InsertObjectWFObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/insert_update_object_wf_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    comments(body: ObjectWFCommentsObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/insert_object_wf_comments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments(_response);
        });
    }

    protected processComments(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class ReassignedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    task(body: UpdateTasksObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/update_reassigned_task";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTask(_response);
        });
    }

    protected processTask(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class StartClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bit(body: ObjectWFStarObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ObjectWF/update_object_wf_task_status_start_bit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBit(_response);
        });
    }

    protected processBit(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class EntityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    details(body: InsertOtherEntityObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/OtherEntity/insert_other_entity_details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param otherEntityID (optional) 
     * @param relatedEntityID (optional) 
     * @param entitySubTypeID (optional) 
     * @param output (optional) 
     * @return OK
     */
    details(otherEntityID: number | undefined, relatedEntityID: number | undefined, entitySubTypeID: number | undefined, output: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/OtherEntity/delete_other_entity_details?";
        if (otherEntityID === null)
            throw new Error("The parameter 'otherEntityID' cannot be null.");
        else if (otherEntityID !== undefined)
            url_ += "otherEntityID=" + encodeURIComponent("" + otherEntityID) + "&";
        if (relatedEntityID === null)
            throw new Error("The parameter 'relatedEntityID' cannot be null.");
        else if (relatedEntityID !== undefined)
            url_ += "relatedEntityID=" + encodeURIComponent("" + relatedEntityID) + "&";
        if (entitySubTypeID === null)
            throw new Error("The parameter 'entitySubTypeID' cannot be null.");
        else if (entitySubTypeID !== undefined)
            url_ += "entitySubTypeID=" + encodeURIComponent("" + entitySubTypeID) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class RelatedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    entity(body: InsertRelatedEntityObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/OtherEntity/insert_related_entity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEntity(_response);
        });
    }

    protected processEntity(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class DetailsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param otherEntityID (optional) 
     * @param relatedEntityID (optional) 
     * @return OK
     */
    list(firmId: number | undefined, otherEntityID: number | undefined, relatedEntityID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/OtherEntity/get_corporate_controller_details_list?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (otherEntityID === null)
            throw new Error("The parameter 'otherEntityID' cannot be null.");
        else if (otherEntityID !== undefined)
            url_ += "otherEntityID=" + encodeURIComponent("" + otherEntityID) + "&";
        if (relatedEntityID === null)
            throw new Error("The parameter 'relatedEntityID' cannot be null.");
        else if (relatedEntityID !== undefined)
            url_ += "relatedEntityID=" + encodeURIComponent("" + relatedEntityID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class OfClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param controllerTypeID (optional) 
     * @param otherEntityID (optional) 
     * @param contactID (optional) 
     * @return OK
     */
    shares(firmId: number | undefined, controllerTypeID: number | undefined, otherEntityID: number | undefined, contactID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/OtherEntity/get_total_pc_of_shares?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (controllerTypeID === null)
            throw new Error("The parameter 'controllerTypeID' cannot be null.");
        else if (controllerTypeID !== undefined)
            url_ += "controllerTypeID=" + encodeURIComponent("" + controllerTypeID) + "&";
        if (otherEntityID === null)
            throw new Error("The parameter 'otherEntityID' cannot be null.");
        else if (otherEntityID !== undefined)
            url_ += "otherEntityID=" + encodeURIComponent("" + otherEntityID) + "&";
        if (contactID === null)
            throw new Error("The parameter 'contactID' cannot be null.");
        else if (contactID !== undefined)
            url_ += "contactID=" + encodeURIComponent("" + contactID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShares(_response);
        });
    }

    protected processShares(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    firm(firmId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_licensed_or_authorised_date_of_firm?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFirm(_response);
        });
    }

    protected processFirm(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class RegulatorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param otherEntityID (optional) 
     * @param entityTypeId (optional) 
     * @return OK
     */
    details(otherEntityID: number | undefined, entityTypeId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ParentEntity/get_regulator_details?";
        if (otherEntityID === null)
            throw new Error("The parameter 'otherEntityID' cannot be null.");
        else if (otherEntityID !== undefined)
            url_ += "otherEntityID=" + encodeURIComponent("" + otherEntityID) + "&";
        if (entityTypeId === null)
            throw new Error("The parameter 'entityTypeId' cannot be null.");
        else if (entityTypeId !== undefined)
            url_ += "entityTypeId=" + encodeURIComponent("" + entityTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    data(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReturnView/get_regulator_data?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class FundClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @param firmId (optional) 
     * @param registeredFundID (optional) 
     * @return OK
     */
    data(userId: number | undefined, firmId: number | undefined, registeredFundID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/RegisteredFund/get_registered_fund_data?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (registeredFundID === null)
            throw new Error("The parameter 'registeredFundID' cannot be null.");
        else if (registeredFundID !== undefined)
            url_ += "registeredFundID=" + encodeURIComponent("" + registeredFundID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param registeredFundID (optional) 
     * @return OK
     */
    status(registeredFundID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/RegisteredFund/get_registered_fund_status?";
        if (registeredFundID === null)
            throw new Error("The parameter 'registeredFundID' cannot be null.");
        else if (registeredFundID !== undefined)
            url_ += "registeredFundID=" + encodeURIComponent("" + registeredFundID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param registeredFundID (optional) 
     * @return OK
     */
    data(registeredFundID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/RegisteredFund/get_sub_fund_data?";
        if (registeredFundID === null)
            throw new Error("The parameter 'registeredFundID' cannot be null.");
        else if (registeredFundID !== undefined)
            url_ += "registeredFundID=" + encodeURIComponent("" + registeredFundID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class RegisteredClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param registeredFundID (optional) 
     * @return OK
     */
    fund(registeredFundID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/RegisteredFund/delete_registered_fund?";
        if (registeredFundID === null)
            throw new Error("The parameter 'registeredFundID' cannot be null.");
        else if (registeredFundID !== undefined)
            url_ += "registeredFundID=" + encodeURIComponent("" + registeredFundID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFund(_response);
        });
    }

    protected processFund(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ScheduleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param reportSchID (optional) 
     * @return OK
     */
    items(firmId: number | undefined, reportSchID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_report_schedule_items?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (reportSchID === null)
            throw new Error("The parameter 'reportSchID' cannot be null.");
        else if (reportSchID !== undefined)
            url_ += "reportSchID=" + encodeURIComponent("" + reportSchID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItems(_response);
        });
    }

    protected processItems(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmRptSchItemID (optional) 
     * @return OK
     */
    item(firmRptSchItemID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_firm_report_schedule_item?";
        if (firmRptSchItemID === null)
            throw new Error("The parameter 'firmRptSchItemID' cannot be null.");
        else if (firmRptSchItemID !== undefined)
            url_ += "firmRptSchItemID=" + encodeURIComponent("" + firmRptSchItemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItem(_response);
        });
    }

    protected processItem(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param firmReportingFrom (optional) 
     * @param firmReportingTo (optional) 
     * @param validateFlag (optional) 
     * @return OK
     */
    generated(firmId: number | undefined, firmReportingFrom: string | undefined, firmReportingTo: string | undefined, validateFlag: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/is_reporting_schedule_generated?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmReportingFrom === null)
            throw new Error("The parameter 'firmReportingFrom' cannot be null.");
        else if (firmReportingFrom !== undefined)
            url_ += "firmReportingFrom=" + encodeURIComponent("" + firmReportingFrom) + "&";
        if (firmReportingTo === null)
            throw new Error("The parameter 'firmReportingTo' cannot be null.");
        else if (firmReportingTo !== undefined)
            url_ += "firmReportingTo=" + encodeURIComponent("" + firmReportingTo) + "&";
        if (validateFlag === null)
            throw new Error("The parameter 'validateFlag' cannot be null.");
        else if (validateFlag !== undefined)
            url_ += "ValidateFlag=" + encodeURIComponent("" + validateFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerated(_response);
        });
    }

    protected processGenerated(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    link(body: UpdateWaiverScheduleObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/update_waiver_schedule_link";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLink(_response);
        });
    }

    protected processLink(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ReportingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param firmRptSchID (optional) 
     * @return OK
     */
    period(firmId: number | undefined, firmRptSchID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_financial_reporting_period?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmRptSchID === null)
            throw new Error("The parameter 'firmRptSchID' cannot be null.");
        else if (firmRptSchID !== undefined)
            url_ += "firmRptSchID=" + encodeURIComponent("" + firmRptSchID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPeriod(_response);
        });
    }

    protected processPeriod(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param firmRptSchID (optional) 
     * @return OK
     */
    schedule(firmId: number | undefined, firmRptSchID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/delete_reporting_schedule?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmRptSchID === null)
            throw new Error("The parameter 'firmRptSchID' cannot be null.");
        else if (firmRptSchID !== undefined)
            url_ += "firmRptSchID=" + encodeURIComponent("" + firmRptSchID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSchedule(_response);
        });
    }

    protected processSchedule(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param firmReportingFrom (optional) 
     * @param firmReportingTo (optional) 
     * @return OK
     */
    schedule(firmId: number | undefined, firmReportingFrom: string | undefined, firmReportingTo: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/validate_reporting_schedule?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmReportingFrom === null)
            throw new Error("The parameter 'firmReportingFrom' cannot be null.");
        else if (firmReportingFrom !== undefined)
            url_ += "firmReportingFrom=" + encodeURIComponent("" + firmReportingFrom) + "&";
        if (firmReportingTo === null)
            throw new Error("The parameter 'firmReportingTo' cannot be null.");
        else if (firmReportingTo !== undefined)
            url_ += "firmReportingTo=" + encodeURIComponent("" + firmReportingTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSchedule(_response);
        });
    }

    protected processSchedule(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    schedule(body: PublishReportingObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/publish_reporting_schedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSchedule(_response);
        });
    }

    protected processSchedule(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @param firmRptShcItemID (optional) 
     * @return OK
     */
    basis(firmId: number | undefined, firmRptShcItemID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReturnView/get_reporting_basis?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmRptShcItemID === null)
            throw new Error("The parameter 'firmRptShcItemID' cannot be null.");
        else if (firmRptShcItemID !== undefined)
            url_ += "firmRptShcItemID=" + encodeURIComponent("" + firmRptShcItemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBasis(_response);
        });
    }

    protected processBasis(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class PeriodClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    types(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_rpt_period_types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param docTypeId (optional) 
     * @return OK
     */
    types(docTypeId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/get_regular_rpt_period_types?";
        if (docTypeId === null)
            throw new Error("The parameter 'docTypeId' cannot be null.");
        else if (docTypeId !== undefined)
            url_ += "docTypeId=" + encodeURIComponent("" + docTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTypes(_response);
        });
    }

    protected processTypes(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class DateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param docTypeId (optional) 
     * @param reportingPeriodTo (optional) 
     * @return OK
     */
    valid(docTypeId: number | undefined, reportingPeriodTo: Date | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReportSchedule/is_reporting_to_date_valid?";
        if (docTypeId === null)
            throw new Error("The parameter 'docTypeId' cannot be null.");
        else if (docTypeId !== undefined)
            url_ += "docTypeId=" + encodeURIComponent("" + docTypeId) + "&";
        if (reportingPeriodTo === null)
            throw new Error("The parameter 'reportingPeriodTo' cannot be null.");
        else if (reportingPeriodTo !== undefined)
            url_ += "reportingPeriodTo=" + encodeURIComponent(reportingPeriodTo ? "" + reportingPeriodTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValid(_response);
        });
    }

    protected processValid(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ReportsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param firmRptReviewId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    received(firmId: number | undefined, firmRptReviewId: number | undefined, userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/ReturnView/get_reports_received?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmRptReviewId === null)
            throw new Error("The parameter 'firmRptReviewId' cannot be null.");
        else if (firmRptReviewId !== undefined)
            url_ += "firmRptReviewId=" + encodeURIComponent("" + firmRptReviewId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReceived(_response);
        });
    }

    protected processReceived(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ReviewClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param rptObjectID (optional) 
     * @param rptReviewID (optional) 
     * @param rptReviewRevNum (optional) 
     * @param output (optional) 
     * @return OK
     */
    details(rptObjectID: number | undefined, rptReviewID: number | undefined, rptReviewRevNum: number | undefined, output: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReturnView/delete_rpt_review_details?";
        if (rptObjectID === null)
            throw new Error("The parameter 'rptObjectID' cannot be null.");
        else if (rptObjectID !== undefined)
            url_ += "rptObjectID=" + encodeURIComponent("" + rptObjectID) + "&";
        if (rptReviewID === null)
            throw new Error("The parameter 'rptReviewID' cannot be null.");
        else if (rptReviewID !== undefined)
            url_ += "rptReviewID=" + encodeURIComponent("" + rptReviewID) + "&";
        if (rptReviewRevNum === null)
            throw new Error("The parameter 'rptReviewRevNum' cannot be null.");
        else if (rptReviewRevNum !== undefined)
            url_ += "rptReviewRevNum=" + encodeURIComponent("" + rptReviewRevNum) + "&";
        if (output === null)
            throw new Error("The parameter 'output' cannot be null.");
        else if (output !== undefined)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ExternalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    ref(body: InsertFirmRptObj | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/ReturnView/insert_firm_rpt_sch_item_external_ref";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRef(_response);
        });
    }

    protected processRef(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class ExtClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    notifications(body: InsertExtNotObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/ReturnView/save_ext_notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications(_response);
        });
    }

    protected processNotifications(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ActionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmRMPID (optional) 
     * @param firmRiskID (optional) 
     * @param firmRiskVerNum (optional) 
     * @return OK
     */
    items(firmRMPID: number | undefined, firmRiskID: number | undefined, firmRiskVerNum: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_risks_and_risk_action_items?";
        if (firmRMPID === null)
            throw new Error("The parameter 'firmRMPID' cannot be null.");
        else if (firmRMPID !== undefined)
            url_ += "firmRMPID=" + encodeURIComponent("" + firmRMPID) + "&";
        if (firmRiskID === null)
            throw new Error("The parameter 'firmRiskID' cannot be null.");
        else if (firmRiskID !== undefined)
            url_ += "firmRiskID=" + encodeURIComponent("" + firmRiskID) + "&";
        if (firmRiskVerNum === null)
            throw new Error("The parameter 'firmRiskVerNum' cannot be null.");
        else if (firmRiskVerNum !== undefined)
            url_ += "firmRiskVerNum=" + encodeURIComponent("" + firmRiskVerNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItems(_response);
        });
    }

    protected processItems(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param firmRiskID (optional) 
     * @param firmRiskRevNum (optional) 
     * @param actionItemID (optional) 
     * @return OK
     */
    items(firmRiskID: number | undefined, firmRiskRevNum: number | undefined, actionItemID: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Risk/delete_risk_action_items?";
        if (firmRiskID === null)
            throw new Error("The parameter 'firmRiskID' cannot be null.");
        else if (firmRiskID !== undefined)
            url_ += "firmRiskID=" + encodeURIComponent("" + firmRiskID) + "&";
        if (firmRiskRevNum === null)
            throw new Error("The parameter 'firmRiskRevNum' cannot be null.");
        else if (firmRiskRevNum !== undefined)
            url_ += "firmRiskRevNum=" + encodeURIComponent("" + firmRiskRevNum) + "&";
        if (actionItemID === null)
            throw new Error("The parameter 'actionItemID' cannot be null.");
        else if (actionItemID !== undefined)
            url_ += "actionItemID=" + encodeURIComponent("" + actionItemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItems(_response);
        });
    }

    protected processItems(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param waiverID (optional) 
     * @param waiverRevNum (optional) 
     * @return OK
     */
    item(waiverID: number | undefined, waiverRevNum: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/get_waiver_exp_action_item?";
        if (waiverID === null)
            throw new Error("The parameter 'waiverID' cannot be null.");
        else if (waiverID !== undefined)
            url_ += "waiverID=" + encodeURIComponent("" + waiverID) + "&";
        if (waiverRevNum === null)
            throw new Error("The parameter 'waiverRevNum' cannot be null.");
        else if (waiverRevNum !== undefined)
            url_ += "waiverRevNum=" + encodeURIComponent("" + waiverRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItem(_response);
        });
    }

    protected processItem(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    item(body: WaiverExceptionObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/update_waiver_exp_action_item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItem(_response);
        });
    }

    protected processItem(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class RiskClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmRMPID (optional) 
     * @param isOnlyRiskApprovedReqd (optional) 
     * @return OK
     */
    list(firmRMPID: number | undefined, isOnlyRiskApprovedReqd: boolean | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_firm_risk_list?";
        if (firmRMPID === null)
            throw new Error("The parameter 'firmRMPID' cannot be null.");
        else if (firmRMPID !== undefined)
            url_ += "firmRMPID=" + encodeURIComponent("" + firmRMPID) + "&";
        if (isOnlyRiskApprovedReqd === null)
            throw new Error("The parameter 'isOnlyRiskApprovedReqd' cannot be null.");
        else if (isOnlyRiskApprovedReqd !== undefined)
            url_ += "isOnlyRiskApprovedReqd=" + encodeURIComponent("" + isOnlyRiskApprovedReqd) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param riskGroupTypeID (optional) 
     * @return OK
     */
    number(riskGroupTypeID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_risk_number?";
        if (riskGroupTypeID === null)
            throw new Error("The parameter 'riskGroupTypeID' cannot be null.");
        else if (riskGroupTypeID !== undefined)
            url_ += "riskGroupTypeID=" + encodeURIComponent("" + riskGroupTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNumber(_response);
        });
    }

    protected processNumber(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param objectActionItemID (optional) 
     * @return OK
     */
    update(objectActionItemID: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Risk/delete_risk_update?";
        if (objectActionItemID === null)
            throw new Error("The parameter 'objectActionItemID' cannot be null.");
        else if (objectActionItemID !== undefined)
            url_ += "objectActionItemID=" + encodeURIComponent("" + objectActionItemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param firmRiskIDsNVerNum (optional) 
     * @param objectActionItemID (optional) 
     * @return OK
     */
    update(firmRiskIDsNVerNum: string | undefined, objectActionItemID: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Risk/delete_risks_risk_update?";
        if (firmRiskIDsNVerNum === null)
            throw new Error("The parameter 'firmRiskIDsNVerNum' cannot be null.");
        else if (firmRiskIDsNVerNum !== undefined)
            url_ += "firmRiskIDsNVerNum=" + encodeURIComponent("" + firmRiskIDsNVerNum) + "&";
        if (objectActionItemID === null)
            throw new Error("The parameter 'objectActionItemID' cannot be null.");
        else if (objectActionItemID !== undefined)
            url_ += "objectActionItemID=" + encodeURIComponent("" + objectActionItemID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param objectInstanceID (optional) 
     * @return OK
     */
    updates(objectInstanceID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_risk_updates?";
        if (objectInstanceID === null)
            throw new Error("The parameter 'objectInstanceID' cannot be null.");
        else if (objectInstanceID !== undefined)
            url_ += "objectInstanceID=" + encodeURIComponent("" + objectInstanceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdates(_response);
        });
    }

    protected processUpdates(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmRiskID (optional) 
     * @param firmRiskRevNum (optional) 
     * @return OK
     */
    updated(firmRiskID: number | undefined, firmRiskRevNum: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/is_risk_referenced_in_risk_updated?";
        if (firmRiskID === null)
            throw new Error("The parameter 'firmRiskID' cannot be null.");
        else if (firmRiskID !== undefined)
            url_ += "firmRiskID=" + encodeURIComponent("" + firmRiskID) + "&";
        if (firmRiskRevNum === null)
            throw new Error("The parameter 'firmRiskRevNum' cannot be null.");
        else if (firmRiskRevNum !== undefined)
            url_ += "firmRiskRevNum=" + encodeURIComponent("" + firmRiskRevNum) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdated(_response);
        });
    }

    protected processUpdated(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(body: FirmRiskStatusObj | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/insert_firm_risk_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    rating(body: RiskRating | undefined): Promise<StringBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/insert_risk_rating";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRating(_response);
        });
    }

    protected processRating(response: Response): Promise<StringBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringBaseResponse>(null as any);
    }
}

export class GroupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param riskGroupTypeID (optional) 
     * @return OK
     */
    factor(riskGroupTypeID: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_risk_group_factor?";
        if (riskGroupTypeID === null)
            throw new Error("The parameter 'riskGroupTypeID' cannot be null.");
        else if (riskGroupTypeID !== undefined)
            url_ += "riskGroupTypeID=" + encodeURIComponent("" + riskGroupTypeID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFactor(_response);
        });
    }

    protected processFactor(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class RmpClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    list(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_rmp_list?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class CarryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param firmRMPID (optional) 
     * @return OK
     */
    forward(firmId: number | undefined, firmRMPID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_risk_to_carry_forward?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (firmRMPID === null)
            throw new Error("The parameter 'firmRMPID' cannot be null.");
        else if (firmRMPID !== undefined)
            url_ += "firmRMPID=" + encodeURIComponent("" + firmRMPID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForward(_response);
        });
    }

    protected processForward(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    forward(body: RiskToCarryObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/insert_risk_to_carry_forward";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForward(_response);
        });
    }

    protected processForward(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class CountryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    code(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_country_code";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCode(_response);
        });
    }

    protected processCode(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class RatingsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    data(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get_credit_ratings_data?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    getRiskGroupFactor(): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Risk/get-risk-group-factor";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRiskGroupFactor(_response);
        });
    }

    protected processGetRiskGroupFactor(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    getApplicableTabs(userId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/get-applicable-tabs?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApplicableTabs(_response);
        });
    }

    protected processGetApplicableTabs(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class TaskReminderClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    list(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/get_task-reminder_list?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class SecondaryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    officer(userId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/get_my_tasks_secondary_officer?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOfficer(_response);
        });
    }

    protected processOfficer(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class TeamsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @param teamUsersID (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    task(userId: number | undefined, teamUsersID: string | undefined, fromDate: string | undefined, toDate: string | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/get_my_teams_task?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (teamUsersID === null)
            throw new Error("The parameter 'teamUsersID' cannot be null.");
        else if (teamUsersID !== undefined)
            url_ += "teamUsersID=" + encodeURIComponent("" + teamUsersID) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTask(_response);
        });
    }

    protected processTask(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }
}

export class ReminderClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    note(body: ReminderNoteObject | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/insert_reminder_note";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNote(_response);
        });
    }

    protected processNote(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class PersonalClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reminder(body: PersonalReminderObject | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Task/insert_personal_reminder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReminder(_response);
        });
    }

    protected processReminder(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class WithClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @return OK
     */
    subordinates(userId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/get_user_with_subordinates?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubordinates(_response);
        });
    }

    protected processSubordinates(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class RestrictedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param userId (optional) 
     * @param firmId (optional) 
     * @param objectID (optional) 
     * @return OK
     */
    access(userId: number | undefined, firmId: number | undefined, objectID: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Users/is_user_has_restricted_access?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (objectID === null)
            throw new Error("The parameter 'objectID' cannot be null.");
        else if (objectID !== undefined)
            url_ += "objectID=" + encodeURIComponent("" + objectID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccess(_response);
        });
    }

    protected processAccess(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class NumberClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param waiverNumber (optional) 
     * @return OK
     */
    exists(waiverNumber: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/check_waiver_number_exists?";
        if (waiverNumber === null)
            throw new Error("The parameter 'waiverNumber' cannot be null.");
        else if (waiverNumber !== undefined)
            url_ += "waiverNumber=" + encodeURIComponent("" + waiverNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExists(_response);
        });
    }

    protected processExists(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param revocationNumber (optional) 
     * @return OK
     */
    exists(revocationNumber: string | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/check_revocation_number_exists?";
        if (revocationNumber === null)
            throw new Error("The parameter 'revocationNumber' cannot be null.");
        else if (revocationNumber !== undefined)
            url_ += "revocationNumber=" + encodeURIComponent("" + revocationNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExists(_response);
        });
    }

    protected processExists(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class WaiverClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param firmId (optional) 
     * @param roleId (optional) 
     * @param objectOpType (optional) 
     * @return OK
     */
    list(firmId: number | undefined, roleId: number | undefined, objectOpType: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/get_waiver_list?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (objectOpType === null)
            throw new Error("The parameter 'objectOpType' cannot be null.");
        else if (objectOpType !== undefined)
            url_ += "objectOpType=" + encodeURIComponent("" + objectOpType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param firmId (optional) 
     * @return OK
     */
    number(firmId: number | undefined): Promise<StringObjectDictionaryListBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/get_existing_waiver_number?";
        if (firmId === null)
            throw new Error("The parameter 'firmId' cannot be null.");
        else if (firmId !== undefined)
            url_ += "firmId=" + encodeURIComponent("" + firmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNumber(_response);
        });
    }

    protected processNumber(response: Response): Promise<StringObjectDictionaryListBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryListBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryListBaseResponse>(null as any);
    }

    /**
     * @param existingWaiverID (optional) 
     * @param waiverRevisionNumber (optional) 
     * @return OK
     */
    details(existingWaiverID: number | undefined, waiverRevisionNumber: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/get_existing_waiver_details?";
        if (existingWaiverID === null)
            throw new Error("The parameter 'existingWaiverID' cannot be null.");
        else if (existingWaiverID !== undefined)
            url_ += "existingWaiverID=" + encodeURIComponent("" + existingWaiverID) + "&";
        if (waiverRevisionNumber === null)
            throw new Error("The parameter 'waiverRevisionNumber' cannot be null.");
        else if (waiverRevisionNumber !== undefined)
            url_ += "waiverRevisionNumber=" + encodeURIComponent("" + waiverRevisionNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    object(body: InsertWaiverObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/save_waiver_object";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processObject(_response);
        });
    }

    protected processObject(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    revision(body: WaiverRevisionObj | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/create_waiver_revision";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevision(_response);
        });
    }

    protected processRevision(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class ViewClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param waiverID (optional) 
     * @param waiverRevisionNumber (optional) 
     * @return OK
     */
    details(waiverID: number | undefined, waiverRevisionNumber: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/get_waiver_view_details?";
        if (waiverID === null)
            throw new Error("The parameter 'waiverID' cannot be null.");
        else if (waiverID !== undefined)
            url_ += "waiverID=" + encodeURIComponent("" + waiverID) + "&";
        if (waiverRevisionNumber === null)
            throw new Error("The parameter 'waiverRevisionNumber' cannot be null.");
        else if (waiverRevisionNumber !== undefined)
            url_ += "waiverRevisionNumber=" + encodeURIComponent("" + waiverRevisionNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class PreviousClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param legislationId (optional) 
     * @param partTypeId (optional) 
     * @param raProvisionsFromRef (optional) 
     * @param raProvisionsToRef (optional) 
     * @param raProvisionsFromId (optional) 
     * @param raProvisionsToId (optional) 
     * @return OK
     */
    precedents(legislationId: number | undefined, partTypeId: number | undefined, raProvisionsFromRef: string | undefined, raProvisionsToRef: string | undefined, raProvisionsFromId: number | undefined, raProvisionsToId: number | undefined): Promise<StringObjectDictionaryBaseResponse> {
        let url_ = this.baseUrl + "/api/Waiver/get_waiver_previous_precedents?";
        if (legislationId === null)
            throw new Error("The parameter 'legislationId' cannot be null.");
        else if (legislationId !== undefined)
            url_ += "legislationId=" + encodeURIComponent("" + legislationId) + "&";
        if (partTypeId === null)
            throw new Error("The parameter 'partTypeId' cannot be null.");
        else if (partTypeId !== undefined)
            url_ += "partTypeId=" + encodeURIComponent("" + partTypeId) + "&";
        if (raProvisionsFromRef === null)
            throw new Error("The parameter 'raProvisionsFromRef' cannot be null.");
        else if (raProvisionsFromRef !== undefined)
            url_ += "raProvisionsFromRef=" + encodeURIComponent("" + raProvisionsFromRef) + "&";
        if (raProvisionsToRef === null)
            throw new Error("The parameter 'raProvisionsToRef' cannot be null.");
        else if (raProvisionsToRef !== undefined)
            url_ += "raProvisionsToRef=" + encodeURIComponent("" + raProvisionsToRef) + "&";
        if (raProvisionsFromId === null)
            throw new Error("The parameter 'raProvisionsFromId' cannot be null.");
        else if (raProvisionsFromId !== undefined)
            url_ += "raProvisionsFromId=" + encodeURIComponent("" + raProvisionsFromId) + "&";
        if (raProvisionsToId === null)
            throw new Error("The parameter 'raProvisionsToId' cannot be null.");
        else if (raProvisionsToId !== undefined)
            url_ += "raProvisionsToId=" + encodeURIComponent("" + raProvisionsToId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPrecedents(_response);
        });
    }

    protected processPrecedents(response: Response): Promise<StringObjectDictionaryBaseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringObjectDictionaryBaseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringObjectDictionaryBaseResponse>(null as any);
    }
}

export class AIsView implements IAIsView {
    ainId?: number | undefined;
    contactId?: number | undefined;
    natinality?: number | undefined;
    countryOfResidence?: number | undefined;
    functionId?: number | undefined;
    formTypeId?: number | undefined;
    formProcessorId?: number | undefined;
    statusofApplicationId?: number | undefined;
    applicatioState?: number | undefined;
    fromType?: number | undefined;
    contactAssId?: number | undefined;
    firmId?: number | undefined;
    prefferdMethod?: number | undefined;
    customFacingId?: number | undefined;
    ainNumber?: string | undefined;
    title?: string | undefined;
    firstName?: string | undefined;
    secondName?: string | undefined;
    thirdName?: string | undefined;
    familyname?: string | undefined;
    fullName?: string | undefined;
    previousName?: string | undefined;
    dateOfBirth?: string | undefined;
    placeOfBirth?: string | undefined;
    nationality?: string | undefined;
    copyOfResidence?: string | undefined;
    passportNumber?: string | undefined;
    nationalId?: string | undefined;
    functions?: string | undefined;
    conditions?: string | undefined;
    formType?: string | undefined;
    dateRecieved?: string | undefined;
    formProcessor?: string | undefined;
    paymentRequest?: string | undefined;
    paymentRecieved?: string | undefined;
    createdBy?: string | undefined;
    statusOfApplications?: string | undefined;
    statusDate?: string | undefined;
    appicationStatusDate?: string | undefined;
    customFacingActivity?: string | undefined;
    paymentRequestSenton?: string | undefined;
    paymentRecievedon?: string | undefined;
    conditionsRestriction?: string | undefined;
    applicationID?: string | undefined;
    createdDate?: string | undefined;
    mobilePhone?: string | undefined;
    bussinessEmail?: string | undefined;
    otherEmail?: string | undefined;
    prefferedMethodType?: string | undefined;
    showReadOnly?: boolean | undefined;
    showEnabled?: boolean | undefined;

    constructor(data?: IAIsView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ainId = _data["ainId"];
            this.contactId = _data["contactId"];
            this.natinality = _data["natinality"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.functionId = _data["functionId"];
            this.formTypeId = _data["formTypeId"];
            this.formProcessorId = _data["formProcessorId"];
            this.statusofApplicationId = _data["statusofApplicationId"];
            this.applicatioState = _data["applicatioState"];
            this.fromType = _data["fromType"];
            this.contactAssId = _data["contactAssId"];
            this.firmId = _data["firmId"];
            this.prefferdMethod = _data["prefferdMethod"];
            this.customFacingId = _data["customFacingId"];
            this.ainNumber = _data["ainNumber"];
            this.title = _data["title"];
            this.firstName = _data["firstName"];
            this.secondName = _data["secondName"];
            this.thirdName = _data["thirdName"];
            this.familyname = _data["familyname"];
            this.fullName = _data["fullName"];
            this.previousName = _data["previousName"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.placeOfBirth = _data["placeOfBirth"];
            this.nationality = _data["nationality"];
            this.copyOfResidence = _data["copyOfResidence"];
            this.passportNumber = _data["passportNumber"];
            this.nationalId = _data["nationalId"];
            this.functions = _data["functions"];
            this.conditions = _data["conditions"];
            this.formType = _data["formType"];
            this.dateRecieved = _data["dateRecieved"];
            this.formProcessor = _data["formProcessor"];
            this.paymentRequest = _data["paymentRequest"];
            this.paymentRecieved = _data["paymentRecieved"];
            this.createdBy = _data["createdBy"];
            this.statusOfApplications = _data["statusOfApplications"];
            this.statusDate = _data["statusDate"];
            this.appicationStatusDate = _data["appicationStatusDate"];
            this.customFacingActivity = _data["customFacingActivity"];
            this.paymentRequestSenton = _data["paymentRequestSenton"];
            this.paymentRecievedon = _data["paymentRecievedon"];
            this.conditionsRestriction = _data["conditionsRestriction"];
            this.applicationID = _data["applicationID"];
            this.createdDate = _data["createdDate"];
            this.mobilePhone = _data["mobilePhone"];
            this.bussinessEmail = _data["bussinessEmail"];
            this.otherEmail = _data["otherEmail"];
            this.prefferedMethodType = _data["prefferedMethodType"];
            this.showReadOnly = _data["showReadOnly"];
            this.showEnabled = _data["showEnabled"];
        }
    }

    static fromJS(data: any): AIsView {
        data = typeof data === 'object' ? data : {};
        let result = new AIsView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ainId"] = this.ainId;
        data["contactId"] = this.contactId;
        data["natinality"] = this.natinality;
        data["countryOfResidence"] = this.countryOfResidence;
        data["functionId"] = this.functionId;
        data["formTypeId"] = this.formTypeId;
        data["formProcessorId"] = this.formProcessorId;
        data["statusofApplicationId"] = this.statusofApplicationId;
        data["applicatioState"] = this.applicatioState;
        data["fromType"] = this.fromType;
        data["contactAssId"] = this.contactAssId;
        data["firmId"] = this.firmId;
        data["prefferdMethod"] = this.prefferdMethod;
        data["customFacingId"] = this.customFacingId;
        data["ainNumber"] = this.ainNumber;
        data["title"] = this.title;
        data["firstName"] = this.firstName;
        data["secondName"] = this.secondName;
        data["thirdName"] = this.thirdName;
        data["familyname"] = this.familyname;
        data["fullName"] = this.fullName;
        data["previousName"] = this.previousName;
        data["dateOfBirth"] = this.dateOfBirth;
        data["placeOfBirth"] = this.placeOfBirth;
        data["nationality"] = this.nationality;
        data["copyOfResidence"] = this.copyOfResidence;
        data["passportNumber"] = this.passportNumber;
        data["nationalId"] = this.nationalId;
        data["functions"] = this.functions;
        data["conditions"] = this.conditions;
        data["formType"] = this.formType;
        data["dateRecieved"] = this.dateRecieved;
        data["formProcessor"] = this.formProcessor;
        data["paymentRequest"] = this.paymentRequest;
        data["paymentRecieved"] = this.paymentRecieved;
        data["createdBy"] = this.createdBy;
        data["statusOfApplications"] = this.statusOfApplications;
        data["statusDate"] = this.statusDate;
        data["appicationStatusDate"] = this.appicationStatusDate;
        data["customFacingActivity"] = this.customFacingActivity;
        data["paymentRequestSenton"] = this.paymentRequestSenton;
        data["paymentRecievedon"] = this.paymentRecievedon;
        data["conditionsRestriction"] = this.conditionsRestriction;
        data["applicationID"] = this.applicationID;
        data["createdDate"] = this.createdDate;
        data["mobilePhone"] = this.mobilePhone;
        data["bussinessEmail"] = this.bussinessEmail;
        data["otherEmail"] = this.otherEmail;
        data["prefferedMethodType"] = this.prefferedMethodType;
        data["showReadOnly"] = this.showReadOnly;
        data["showEnabled"] = this.showEnabled;
        return data;
    }
}

export interface IAIsView {
    ainId?: number | undefined;
    contactId?: number | undefined;
    natinality?: number | undefined;
    countryOfResidence?: number | undefined;
    functionId?: number | undefined;
    formTypeId?: number | undefined;
    formProcessorId?: number | undefined;
    statusofApplicationId?: number | undefined;
    applicatioState?: number | undefined;
    fromType?: number | undefined;
    contactAssId?: number | undefined;
    firmId?: number | undefined;
    prefferdMethod?: number | undefined;
    customFacingId?: number | undefined;
    ainNumber?: string | undefined;
    title?: string | undefined;
    firstName?: string | undefined;
    secondName?: string | undefined;
    thirdName?: string | undefined;
    familyname?: string | undefined;
    fullName?: string | undefined;
    previousName?: string | undefined;
    dateOfBirth?: string | undefined;
    placeOfBirth?: string | undefined;
    nationality?: string | undefined;
    copyOfResidence?: string | undefined;
    passportNumber?: string | undefined;
    nationalId?: string | undefined;
    functions?: string | undefined;
    conditions?: string | undefined;
    formType?: string | undefined;
    dateRecieved?: string | undefined;
    formProcessor?: string | undefined;
    paymentRequest?: string | undefined;
    paymentRecieved?: string | undefined;
    createdBy?: string | undefined;
    statusOfApplications?: string | undefined;
    statusDate?: string | undefined;
    appicationStatusDate?: string | undefined;
    customFacingActivity?: string | undefined;
    paymentRequestSenton?: string | undefined;
    paymentRecievedon?: string | undefined;
    conditionsRestriction?: string | undefined;
    applicationID?: string | undefined;
    createdDate?: string | undefined;
    mobilePhone?: string | undefined;
    bussinessEmail?: string | undefined;
    otherEmail?: string | undefined;
    prefferedMethodType?: string | undefined;
    showReadOnly?: boolean | undefined;
    showEnabled?: boolean | undefined;
}

export class AddressDto implements IAddressDto {
    firmId?: number | undefined;
    countryID?: number | undefined;
    addressTypeID?: number | undefined;
    sameAsTypeID?: number | undefined;
    lastModifiedBy?: number | undefined;
    addressAssnID?: number | undefined;
    entityTypeID?: number | undefined;
    entityID?: number | undefined;
    contactAssnID?: number | undefined;
    contactID?: number | undefined;
    addressID?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    postalCode?: string | undefined;
    phoneNumber?: string | undefined;
    phoneExt?: string | undefined;
    faxNumber?: string | undefined;
    lastModifiedDate?: Date | undefined;
    addressState?: number | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNumber?: number | undefined;
    sourceObjectID?: number | undefined;
    sourceObjectInstanceID?: number | undefined;
    sourceObjectInstanceRevNumber?: number | undefined;
    objAis?: AIsView;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.countryID = _data["countryID"];
            this.addressTypeID = _data["addressTypeID"];
            this.sameAsTypeID = _data["sameAsTypeID"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.addressAssnID = _data["addressAssnID"];
            this.entityTypeID = _data["entityTypeID"];
            this.entityID = _data["entityID"];
            this.contactAssnID = _data["contactAssnID"];
            this.contactID = _data["contactID"];
            this.addressID = _data["addressID"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.addressLine3 = _data["addressLine3"];
            this.addressLine4 = _data["addressLine4"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneExt = _data["phoneExt"];
            this.faxNumber = _data["faxNumber"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.addressState = _data["addressState"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.objectInstanceRevNumber = _data["objectInstanceRevNumber"];
            this.sourceObjectID = _data["sourceObjectID"];
            this.sourceObjectInstanceID = _data["sourceObjectInstanceID"];
            this.sourceObjectInstanceRevNumber = _data["sourceObjectInstanceRevNumber"];
            this.objAis = _data["objAis"] ? AIsView.fromJS(_data["objAis"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["countryID"] = this.countryID;
        data["addressTypeID"] = this.addressTypeID;
        data["sameAsTypeID"] = this.sameAsTypeID;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["addressAssnID"] = this.addressAssnID;
        data["entityTypeID"] = this.entityTypeID;
        data["entityID"] = this.entityID;
        data["contactAssnID"] = this.contactAssnID;
        data["contactID"] = this.contactID;
        data["addressID"] = this.addressID;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["addressLine3"] = this.addressLine3;
        data["addressLine4"] = this.addressLine4;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneExt"] = this.phoneExt;
        data["faxNumber"] = this.faxNumber;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["addressState"] = this.addressState;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["objectInstanceRevNumber"] = this.objectInstanceRevNumber;
        data["sourceObjectID"] = this.sourceObjectID;
        data["sourceObjectInstanceID"] = this.sourceObjectInstanceID;
        data["sourceObjectInstanceRevNumber"] = this.sourceObjectInstanceRevNumber;
        data["objAis"] = this.objAis ? this.objAis.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddressDto {
    firmId?: number | undefined;
    countryID?: number | undefined;
    addressTypeID?: number | undefined;
    sameAsTypeID?: number | undefined;
    lastModifiedBy?: number | undefined;
    addressAssnID?: number | undefined;
    entityTypeID?: number | undefined;
    entityID?: number | undefined;
    contactAssnID?: number | undefined;
    contactID?: number | undefined;
    addressID?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    addressLine3?: string | undefined;
    addressLine4?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    postalCode?: string | undefined;
    phoneNumber?: string | undefined;
    phoneExt?: string | undefined;
    faxNumber?: string | undefined;
    lastModifiedDate?: Date | undefined;
    addressState?: number | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNumber?: number | undefined;
    sourceObjectID?: number | undefined;
    sourceObjectInstanceID?: number | undefined;
    sourceObjectInstanceRevNumber?: number | undefined;
    objAis?: AIsView;
}

export class BooleanBaseResponse implements IBooleanBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: boolean;

    constructor(data?: IBooleanBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): BooleanBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response;
        return data;
    }
}

export interface IBooleanBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: boolean;
}

export class ContactDetailsObj implements IContactDetailsObj {
    firmId?: number | undefined;
    contactID?: number | undefined;
    title?: string | undefined;
    firstName?: string | undefined;
    secondName?: string | undefined;
    thirdName?: string | undefined;
    familyName?: string | undefined;
    countryOfResidence?: number | undefined;
    createdBy?: number | undefined;
    dateOfBirth?: Date | undefined;
    fullName?: string | undefined;
    lastModifiedBy?: number | undefined;
    nationalID?: string | undefined;
    nationality?: number | undefined;
    passportNum?: string | undefined;
    placeOfBirth?: string | undefined;
    previousName?: string | undefined;
    isExists?: boolean | undefined;
    nameInPassport?: string | undefined;
    contactAddnlInfoTypeID?: string | undefined;
    isFromContact?: boolean | undefined;
    countryofBirth?: number | undefined;
    juridictionID?: number | undefined;
    objectID?: number | undefined;
    isPeP?: boolean | undefined;

    constructor(data?: IContactDetailsObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.contactID = _data["contactID"];
            this.title = _data["title"];
            this.firstName = _data["firstName"];
            this.secondName = _data["secondName"];
            this.thirdName = _data["thirdName"];
            this.familyName = _data["familyName"];
            this.countryOfResidence = _data["countryOfResidence"];
            this.createdBy = _data["createdBy"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.fullName = _data["fullName"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.nationalID = _data["nationalID"];
            this.nationality = _data["nationality"];
            this.passportNum = _data["passportNum"];
            this.placeOfBirth = _data["placeOfBirth"];
            this.previousName = _data["previousName"];
            this.isExists = _data["isExists"];
            this.nameInPassport = _data["nameInPassport"];
            this.contactAddnlInfoTypeID = _data["contactAddnlInfoTypeID"];
            this.isFromContact = _data["isFromContact"];
            this.countryofBirth = _data["countryofBirth"];
            this.juridictionID = _data["juridictionID"];
            this.objectID = _data["objectID"];
            this.isPeP = _data["isPeP"];
        }
    }

    static fromJS(data: any): ContactDetailsObj {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDetailsObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["contactID"] = this.contactID;
        data["title"] = this.title;
        data["firstName"] = this.firstName;
        data["secondName"] = this.secondName;
        data["thirdName"] = this.thirdName;
        data["familyName"] = this.familyName;
        data["countryOfResidence"] = this.countryOfResidence;
        data["createdBy"] = this.createdBy;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["fullName"] = this.fullName;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["nationalID"] = this.nationalID;
        data["nationality"] = this.nationality;
        data["passportNum"] = this.passportNum;
        data["placeOfBirth"] = this.placeOfBirth;
        data["previousName"] = this.previousName;
        data["isExists"] = this.isExists;
        data["nameInPassport"] = this.nameInPassport;
        data["contactAddnlInfoTypeID"] = this.contactAddnlInfoTypeID;
        data["isFromContact"] = this.isFromContact;
        data["countryofBirth"] = this.countryofBirth;
        data["juridictionID"] = this.juridictionID;
        data["objectID"] = this.objectID;
        data["isPeP"] = this.isPeP;
        return data;
    }
}

export interface IContactDetailsObj {
    firmId?: number | undefined;
    contactID?: number | undefined;
    title?: string | undefined;
    firstName?: string | undefined;
    secondName?: string | undefined;
    thirdName?: string | undefined;
    familyName?: string | undefined;
    countryOfResidence?: number | undefined;
    createdBy?: number | undefined;
    dateOfBirth?: Date | undefined;
    fullName?: string | undefined;
    lastModifiedBy?: number | undefined;
    nationalID?: string | undefined;
    nationality?: number | undefined;
    passportNum?: string | undefined;
    placeOfBirth?: string | undefined;
    previousName?: string | undefined;
    isExists?: boolean | undefined;
    nameInPassport?: string | undefined;
    contactAddnlInfoTypeID?: string | undefined;
    isFromContact?: boolean | undefined;
    countryofBirth?: number | undefined;
    juridictionID?: number | undefined;
    objectID?: number | undefined;
    isPeP?: boolean | undefined;
}

export class DataTableResult implements IDataTableResult {
    key!: string | undefined;
    value!: { [key: string]: any; }[] | undefined;

    constructor(data?: IDataTableResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): DataTableResult {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export interface IDataTableResult {
    key: string | undefined;
    value: { [key: string]: any; }[] | undefined;
}

export class DataTableResultListBaseResponse implements IDataTableResultListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: DataTableResult[] | undefined;

    constructor(data?: IDataTableResultListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(DataTableResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataTableResultListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataTableResultListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDataTableResultListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: DataTableResult[] | undefined;
}

export class DeleteFirmUserObj implements IDeleteFirmUserObj {
    firmUsersID?: string | undefined;
    dateTo?: string | undefined;
    updatedBy?: number | undefined;

    constructor(data?: IDeleteFirmUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmUsersID = _data["firmUsersID"];
            this.dateTo = _data["dateTo"];
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): DeleteFirmUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteFirmUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmUsersID"] = this.firmUsersID;
        data["dateTo"] = this.dateTo;
        data["updatedBy"] = this.updatedBy;
        return data;
    }
}

export interface IDeleteFirmUserObj {
    firmUsersID?: string | undefined;
    dateTo?: string | undefined;
    updatedBy?: number | undefined;
}

export class DeleteScopeObject implements IDeleteScopeObject {
    firmId?: number | undefined;
    scopeId?: number | undefined;
    scopeRevNum?: number | undefined;

    constructor(data?: IDeleteScopeObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.scopeId = _data["scopeId"];
            this.scopeRevNum = _data["scopeRevNum"];
        }
    }

    static fromJS(data: any): DeleteScopeObject {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteScopeObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["scopeId"] = this.scopeId;
        data["scopeRevNum"] = this.scopeRevNum;
        return data;
    }
}

export interface IDeleteScopeObject {
    firmId?: number | undefined;
    scopeId?: number | undefined;
    scopeRevNum?: number | undefined;
}

export class DocMdObj implements IDocMdObj {
    docMDID?: number | undefined;
    docID?: number | undefined;
    docMDDefID?: number | undefined;
    mDTag?: string | undefined;
    mDTagValue?: string | undefined;
    lastModifiedBy?: number | undefined;

    constructor(data?: IDocMdObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docMDID = _data["docMDID"];
            this.docID = _data["docID"];
            this.docMDDefID = _data["docMDDefID"];
            this.mDTag = _data["mDTag"];
            this.mDTagValue = _data["mDTagValue"];
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): DocMdObj {
        data = typeof data === 'object' ? data : {};
        let result = new DocMdObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docMDID"] = this.docMDID;
        data["docID"] = this.docID;
        data["docMDDefID"] = this.docMDDefID;
        data["mDTag"] = this.mDTag;
        data["mDTagValue"] = this.mDTagValue;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IDocMdObj {
    docMDID?: number | undefined;
    docID?: number | undefined;
    docMDDefID?: number | undefined;
    mDTag?: string | undefined;
    mDTagValue?: string | undefined;
    lastModifiedBy?: number | undefined;
}

export class DocSubTypeObj implements IDocSubTypeObj {
    docAttributeID?: number | undefined;
    docID?: number | undefined;
    docTypeID?: number | undefined;
    docSubTypeID?: number | undefined;
    userId?: number | undefined;
    createdDate?: Date | undefined;

    constructor(data?: IDocSubTypeObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docAttributeID = _data["docAttributeID"];
            this.docID = _data["docID"];
            this.docTypeID = _data["docTypeID"];
            this.docSubTypeID = _data["docSubTypeID"];
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocSubTypeObj {
        data = typeof data === 'object' ? data : {};
        let result = new DocSubTypeObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docAttributeID"] = this.docAttributeID;
        data["docID"] = this.docID;
        data["docTypeID"] = this.docTypeID;
        data["docSubTypeID"] = this.docSubTypeID;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDocSubTypeObj {
    docAttributeID?: number | undefined;
    docID?: number | undefined;
    docTypeID?: number | undefined;
    docSubTypeID?: number | undefined;
    userId?: number | undefined;
    createdDate?: Date | undefined;
}

export class EscalationObj implements IEscalationObj {
    breachId?: number | undefined;
    breachRevNum?: number | undefined;
    passedDate?: Date | undefined;
    passedTolrc?: number | undefined;
    updatedby?: number | undefined;

    constructor(data?: IEscalationObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.breachId = _data["breachId"];
            this.breachRevNum = _data["breachRevNum"];
            this.passedDate = _data["passedDate"] ? new Date(_data["passedDate"].toString()) : <any>undefined;
            this.passedTolrc = _data["passedTolrc"];
            this.updatedby = _data["updatedby"];
        }
    }

    static fromJS(data: any): EscalationObj {
        data = typeof data === 'object' ? data : {};
        let result = new EscalationObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["breachId"] = this.breachId;
        data["breachRevNum"] = this.breachRevNum;
        data["passedDate"] = this.passedDate ? this.passedDate.toISOString() : <any>undefined;
        data["passedTolrc"] = this.passedTolrc;
        data["updatedby"] = this.updatedby;
        return data;
    }
}

export interface IEscalationObj {
    breachId?: number | undefined;
    breachRevNum?: number | undefined;
    passedDate?: Date | undefined;
    passedTolrc?: number | undefined;
    updatedby?: number | undefined;
}

export class FirmActivityDto implements IFirmActivityDto {
    createdBy?: number | undefined;
    firmScopeTypeID?: number | undefined;
    activityTypeID?: number | undefined;
    effectiveDate?: Date | undefined;
    firmActivityConditions?: string | undefined;
    productTypeID?: string | undefined;
    appliedDate?: Date | undefined;
    withDrawnDate?: Date | undefined;
    objectProductActivity?: ProductActivityDto[] | undefined;
    activityDetails?: string | undefined;

    constructor(data?: IFirmActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.firmScopeTypeID = _data["firmScopeTypeID"];
            this.activityTypeID = _data["activityTypeID"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.firmActivityConditions = _data["firmActivityConditions"];
            this.productTypeID = _data["productTypeID"];
            this.appliedDate = _data["appliedDate"] ? new Date(_data["appliedDate"].toString()) : <any>undefined;
            this.withDrawnDate = _data["withDrawnDate"] ? new Date(_data["withDrawnDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["objectProductActivity"])) {
                this.objectProductActivity = [] as any;
                for (let item of _data["objectProductActivity"])
                    this.objectProductActivity!.push(ProductActivityDto.fromJS(item));
            }
            this.activityDetails = _data["activityDetails"];
        }
    }

    static fromJS(data: any): FirmActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["firmScopeTypeID"] = this.firmScopeTypeID;
        data["activityTypeID"] = this.activityTypeID;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["firmActivityConditions"] = this.firmActivityConditions;
        data["productTypeID"] = this.productTypeID;
        data["appliedDate"] = this.appliedDate ? this.appliedDate.toISOString() : <any>undefined;
        data["withDrawnDate"] = this.withDrawnDate ? this.withDrawnDate.toISOString() : <any>undefined;
        if (Array.isArray(this.objectProductActivity)) {
            data["objectProductActivity"] = [];
            for (let item of this.objectProductActivity)
                data["objectProductActivity"].push(item.toJSON());
        }
        data["activityDetails"] = this.activityDetails;
        return data;
    }
}

export interface IFirmActivityDto {
    createdBy?: number | undefined;
    firmScopeTypeID?: number | undefined;
    activityTypeID?: number | undefined;
    effectiveDate?: Date | undefined;
    firmActivityConditions?: string | undefined;
    productTypeID?: string | undefined;
    appliedDate?: Date | undefined;
    withDrawnDate?: Date | undefined;
    objectProductActivity?: ProductActivityDto[] | undefined;
    activityDetails?: string | undefined;
}

export class FirmCapitalObj implements IFirmCapitalObj {
    firmCapitalLocationID?: number | undefined;
    firmId?: number | undefined;
    countryID?: number | undefined;
    logInBy?: number | undefined;

    constructor(data?: IFirmCapitalObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmCapitalLocationID = _data["firmCapitalLocationID"];
            this.firmId = _data["firmId"];
            this.countryID = _data["countryID"];
            this.logInBy = _data["logInBy"];
        }
    }

    static fromJS(data: any): FirmCapitalObj {
        data = typeof data === 'object' ? data : {};
        let result = new FirmCapitalObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmCapitalLocationID"] = this.firmCapitalLocationID;
        data["firmId"] = this.firmId;
        data["countryID"] = this.countryID;
        data["logInBy"] = this.logInBy;
        return data;
    }
}

export interface IFirmCapitalObj {
    firmCapitalLocationID?: number | undefined;
    firmId?: number | undefined;
    countryID?: number | undefined;
    logInBy?: number | undefined;
}

export class FirmClassificationObj implements IFirmClassificationObj {
    firmRptClassificationID?: number | undefined;
    firmId?: number | undefined;
    firmRptClassificationTypeID?: number | undefined;
    effectiveFromDate?: Date | undefined;
    createdBy?: number | undefined;

    constructor(data?: IFirmClassificationObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRptClassificationID = _data["firmRptClassificationID"];
            this.firmId = _data["firmId"];
            this.firmRptClassificationTypeID = _data["firmRptClassificationTypeID"];
            this.effectiveFromDate = _data["effectiveFromDate"] ? new Date(_data["effectiveFromDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): FirmClassificationObj {
        data = typeof data === 'object' ? data : {};
        let result = new FirmClassificationObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRptClassificationID"] = this.firmRptClassificationID;
        data["firmId"] = this.firmId;
        data["firmRptClassificationTypeID"] = this.firmRptClassificationTypeID;
        data["effectiveFromDate"] = this.effectiveFromDate ? this.effectiveFromDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IFirmClassificationObj {
    firmRptClassificationID?: number | undefined;
    firmId?: number | undefined;
    firmRptClassificationTypeID?: number | undefined;
    effectiveFromDate?: Date | undefined;
    createdBy?: number | undefined;
}

export class FirmClientClassificationObj implements IFirmClientClassificationObj {
    firmClientsClassificationID?: number | undefined;
    firmId?: number | undefined;
    holdsClientMoney?: boolean | undefined;
    holdsInsuranceMoney?: boolean | undefined;
    holdsClientMoneyDesc?: boolean | undefined;
    holdsInsuranceMoneyDesc?: boolean | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
    firmClientsClassificationDesc?: string | undefined;

    constructor(data?: IFirmClientClassificationObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmClientsClassificationID = _data["firmClientsClassificationID"];
            this.firmId = _data["firmId"];
            this.holdsClientMoney = _data["holdsClientMoney"];
            this.holdsInsuranceMoney = _data["holdsInsuranceMoney"];
            this.holdsClientMoneyDesc = _data["holdsClientMoneyDesc"];
            this.holdsInsuranceMoneyDesc = _data["holdsInsuranceMoneyDesc"];
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.firmClientsClassificationDesc = _data["firmClientsClassificationDesc"];
        }
    }

    static fromJS(data: any): FirmClientClassificationObj {
        data = typeof data === 'object' ? data : {};
        let result = new FirmClientClassificationObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmClientsClassificationID"] = this.firmClientsClassificationID;
        data["firmId"] = this.firmId;
        data["holdsClientMoney"] = this.holdsClientMoney;
        data["holdsInsuranceMoney"] = this.holdsInsuranceMoney;
        data["holdsClientMoneyDesc"] = this.holdsClientMoneyDesc;
        data["holdsInsuranceMoneyDesc"] = this.holdsInsuranceMoneyDesc;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["firmClientsClassificationDesc"] = this.firmClientsClassificationDesc;
        return data;
    }
}

export interface IFirmClientClassificationObj {
    firmClientsClassificationID?: number | undefined;
    firmId?: number | undefined;
    holdsClientMoney?: boolean | undefined;
    holdsInsuranceMoney?: boolean | undefined;
    holdsClientMoneyDesc?: boolean | undefined;
    holdsInsuranceMoneyDesc?: boolean | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
    firmClientsClassificationDesc?: string | undefined;
}

export class FirmDto implements IFirmDto {
    firmId?: number | undefined;
    firmName?: string | undefined;
    qfcNumber?: string | undefined;
    firmCode?: string | undefined;
    legalStatusTypeID?: number | undefined;
    qfcTradingName?: string | undefined;
    prevTradingName?: string | undefined;
    placeOfIncorporation?: string | undefined;
    countyOfIncorporation?: number | undefined;
    webSiteAddress?: string | undefined;
    firmApplDate?: Date | undefined;
    firmApplTypeID?: number | undefined;
    licenseStatusTypeID?: number | undefined;
    licensedDate?: Date | undefined;
    authorisationStatusTypeID?: number | undefined;
    authorisationDate?: Date | undefined;
    createdBy?: number | undefined;
    finYearEndTypeID?: number | undefined;
    firmAccountingDataID?: number | undefined;
    firmApplicationDataComments?: string | undefined;
    firmYearEndEffectiveFrom?: Date | undefined;
    finAccStandardTypeID?: number | undefined;
    finAccStandardID?: number | undefined;
    firmAccountingEffectiveFrom?: Date | undefined;
    dateOfIncorporation?: Date | undefined;
    differentIncorporationDate?: boolean;
    firmNameAsinFactSheet?: string | undefined;
    requiresCoOp?: string | undefined;
    prComments?: string | undefined;

    constructor(data?: IFirmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.firmName = _data["firmName"];
            this.qfcNumber = _data["qfcNumber"];
            this.firmCode = _data["firmCode"];
            this.legalStatusTypeID = _data["legalStatusTypeID"];
            this.qfcTradingName = _data["qfcTradingName"];
            this.prevTradingName = _data["prevTradingName"];
            this.placeOfIncorporation = _data["placeOfIncorporation"];
            this.countyOfIncorporation = _data["countyOfIncorporation"];
            this.webSiteAddress = _data["webSiteAddress"];
            this.firmApplDate = _data["firmApplDate"] ? new Date(_data["firmApplDate"].toString()) : <any>undefined;
            this.firmApplTypeID = _data["firmApplTypeID"];
            this.licenseStatusTypeID = _data["licenseStatusTypeID"];
            this.licensedDate = _data["licensedDate"] ? new Date(_data["licensedDate"].toString()) : <any>undefined;
            this.authorisationStatusTypeID = _data["authorisationStatusTypeID"];
            this.authorisationDate = _data["authorisationDate"] ? new Date(_data["authorisationDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.finYearEndTypeID = _data["finYearEndTypeID"];
            this.firmAccountingDataID = _data["firmAccountingDataID"];
            this.firmApplicationDataComments = _data["firmApplicationDataComments"];
            this.firmYearEndEffectiveFrom = _data["firmYearEndEffectiveFrom"] ? new Date(_data["firmYearEndEffectiveFrom"].toString()) : <any>undefined;
            this.finAccStandardTypeID = _data["finAccStandardTypeID"];
            this.finAccStandardID = _data["finAccStandardID"];
            this.firmAccountingEffectiveFrom = _data["firmAccountingEffectiveFrom"] ? new Date(_data["firmAccountingEffectiveFrom"].toString()) : <any>undefined;
            this.dateOfIncorporation = _data["dateOfIncorporation"] ? new Date(_data["dateOfIncorporation"].toString()) : <any>undefined;
            this.differentIncorporationDate = _data["differentIncorporationDate"];
            this.firmNameAsinFactSheet = _data["firmNameAsinFactSheet"];
            this.requiresCoOp = _data["requiresCoOp"];
            this.prComments = _data["prComments"];
        }
    }

    static fromJS(data: any): FirmDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["firmName"] = this.firmName;
        data["qfcNumber"] = this.qfcNumber;
        data["firmCode"] = this.firmCode;
        data["legalStatusTypeID"] = this.legalStatusTypeID;
        data["qfcTradingName"] = this.qfcTradingName;
        data["prevTradingName"] = this.prevTradingName;
        data["placeOfIncorporation"] = this.placeOfIncorporation;
        data["countyOfIncorporation"] = this.countyOfIncorporation;
        data["webSiteAddress"] = this.webSiteAddress;
        data["firmApplDate"] = this.firmApplDate ? this.firmApplDate.toISOString() : <any>undefined;
        data["firmApplTypeID"] = this.firmApplTypeID;
        data["licenseStatusTypeID"] = this.licenseStatusTypeID;
        data["licensedDate"] = this.licensedDate ? this.licensedDate.toISOString() : <any>undefined;
        data["authorisationStatusTypeID"] = this.authorisationStatusTypeID;
        data["authorisationDate"] = this.authorisationDate ? this.authorisationDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["finYearEndTypeID"] = this.finYearEndTypeID;
        data["firmAccountingDataID"] = this.firmAccountingDataID;
        data["firmApplicationDataComments"] = this.firmApplicationDataComments;
        data["firmYearEndEffectiveFrom"] = this.firmYearEndEffectiveFrom ? this.firmYearEndEffectiveFrom.toISOString() : <any>undefined;
        data["finAccStandardTypeID"] = this.finAccStandardTypeID;
        data["finAccStandardID"] = this.finAccStandardID;
        data["firmAccountingEffectiveFrom"] = this.firmAccountingEffectiveFrom ? this.firmAccountingEffectiveFrom.toISOString() : <any>undefined;
        data["dateOfIncorporation"] = this.dateOfIncorporation ? this.dateOfIncorporation.toISOString() : <any>undefined;
        data["differentIncorporationDate"] = this.differentIncorporationDate;
        data["firmNameAsinFactSheet"] = this.firmNameAsinFactSheet;
        data["requiresCoOp"] = this.requiresCoOp;
        data["prComments"] = this.prComments;
        return data;
    }
}

export interface IFirmDto {
    firmId?: number | undefined;
    firmName?: string | undefined;
    qfcNumber?: string | undefined;
    firmCode?: string | undefined;
    legalStatusTypeID?: number | undefined;
    qfcTradingName?: string | undefined;
    prevTradingName?: string | undefined;
    placeOfIncorporation?: string | undefined;
    countyOfIncorporation?: number | undefined;
    webSiteAddress?: string | undefined;
    firmApplDate?: Date | undefined;
    firmApplTypeID?: number | undefined;
    licenseStatusTypeID?: number | undefined;
    licensedDate?: Date | undefined;
    authorisationStatusTypeID?: number | undefined;
    authorisationDate?: Date | undefined;
    createdBy?: number | undefined;
    finYearEndTypeID?: number | undefined;
    firmAccountingDataID?: number | undefined;
    firmApplicationDataComments?: string | undefined;
    firmYearEndEffectiveFrom?: Date | undefined;
    finAccStandardTypeID?: number | undefined;
    finAccStandardID?: number | undefined;
    firmAccountingEffectiveFrom?: Date | undefined;
    dateOfIncorporation?: Date | undefined;
    differentIncorporationDate?: boolean;
    firmNameAsinFactSheet?: string | undefined;
    requiresCoOp?: string | undefined;
    prComments?: string | undefined;
}

export class FirmIslamicFinanceDto implements IFirmIslamicFinanceDto {
    iFinFlag?: boolean | undefined;
    iFinTypeId?: number | undefined;
    iFinTypeDesc?: string | undefined;
    endorsement?: string | undefined;
    savedIFinTypeID?: number | undefined;
    scopeRevNum?: number | undefined;
    lastModifiedBy?: number | undefined;

    constructor(data?: IFirmIslamicFinanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iFinFlag = _data["iFinFlag"];
            this.iFinTypeId = _data["iFinTypeId"];
            this.iFinTypeDesc = _data["iFinTypeDesc"];
            this.endorsement = _data["endorsement"];
            this.savedIFinTypeID = _data["savedIFinTypeID"];
            this.scopeRevNum = _data["scopeRevNum"];
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): FirmIslamicFinanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmIslamicFinanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iFinFlag"] = this.iFinFlag;
        data["iFinTypeId"] = this.iFinTypeId;
        data["iFinTypeDesc"] = this.iFinTypeDesc;
        data["endorsement"] = this.endorsement;
        data["savedIFinTypeID"] = this.savedIFinTypeID;
        data["scopeRevNum"] = this.scopeRevNum;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IFirmIslamicFinanceDto {
    iFinFlag?: boolean | undefined;
    iFinTypeId?: number | undefined;
    iFinTypeDesc?: string | undefined;
    endorsement?: string | undefined;
    savedIFinTypeID?: number | undefined;
    scopeRevNum?: number | undefined;
    lastModifiedBy?: number | undefined;
}

export class FirmNameHistoryDto implements IFirmNameHistoryDto {
    firmId?: number | undefined;
    prevFirmName?: string | undefined;
    createdBy?: number | undefined;
    firmNameHistoryID?: number | undefined;
    dateEffectiveTo?: Date | undefined;

    constructor(data?: IFirmNameHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.prevFirmName = _data["prevFirmName"];
            this.createdBy = _data["createdBy"];
            this.firmNameHistoryID = _data["firmNameHistoryID"];
            this.dateEffectiveTo = _data["dateEffectiveTo"] ? new Date(_data["dateEffectiveTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FirmNameHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmNameHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["prevFirmName"] = this.prevFirmName;
        data["createdBy"] = this.createdBy;
        data["firmNameHistoryID"] = this.firmNameHistoryID;
        data["dateEffectiveTo"] = this.dateEffectiveTo ? this.dateEffectiveTo.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFirmNameHistoryDto {
    firmId?: number | undefined;
    prevFirmName?: string | undefined;
    createdBy?: number | undefined;
    firmNameHistoryID?: number | undefined;
    dateEffectiveTo?: Date | undefined;
}

export class FirmRiskStatusObj implements IFirmRiskStatusObj {
    firmRiskID?: number | undefined;
    firmRiskRevNumber?: number | undefined;
    objectWFStatusID?: number | undefined;
    createdBy?: number | undefined;
    isRiskRevised?: boolean | undefined;

    constructor(data?: IFirmRiskStatusObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRiskID = _data["firmRiskID"];
            this.firmRiskRevNumber = _data["firmRiskRevNumber"];
            this.objectWFStatusID = _data["objectWFStatusID"];
            this.createdBy = _data["createdBy"];
            this.isRiskRevised = _data["isRiskRevised"];
        }
    }

    static fromJS(data: any): FirmRiskStatusObj {
        data = typeof data === 'object' ? data : {};
        let result = new FirmRiskStatusObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRiskID"] = this.firmRiskID;
        data["firmRiskRevNumber"] = this.firmRiskRevNumber;
        data["objectWFStatusID"] = this.objectWFStatusID;
        data["createdBy"] = this.createdBy;
        data["isRiskRevised"] = this.isRiskRevised;
        return data;
    }
}

export interface IFirmRiskStatusObj {
    firmRiskID?: number | undefined;
    firmRiskRevNumber?: number | undefined;
    objectWFStatusID?: number | undefined;
    createdBy?: number | undefined;
    isRiskRevised?: boolean | undefined;
}

export class FirmRptBasisObj implements IFirmRptBasisObj {
    firmId?: number | undefined;
    firmRptBasisID?: number | undefined;
    firmRptBasisDesc?: string | undefined;
    firmRptBasisTypeID?: number | undefined;
    firmRptBasisTypeDesc?: string | undefined;
    effectiveDate?: string | undefined;
    expirationDate?: string | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;

    constructor(data?: IFirmRptBasisObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.firmRptBasisID = _data["firmRptBasisID"];
            this.firmRptBasisDesc = _data["firmRptBasisDesc"];
            this.firmRptBasisTypeID = _data["firmRptBasisTypeID"];
            this.firmRptBasisTypeDesc = _data["firmRptBasisTypeDesc"];
            this.effectiveDate = _data["effectiveDate"];
            this.expirationDate = _data["expirationDate"];
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FirmRptBasisObj {
        data = typeof data === 'object' ? data : {};
        let result = new FirmRptBasisObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["firmRptBasisID"] = this.firmRptBasisID;
        data["firmRptBasisDesc"] = this.firmRptBasisDesc;
        data["firmRptBasisTypeID"] = this.firmRptBasisTypeID;
        data["firmRptBasisTypeDesc"] = this.firmRptBasisTypeDesc;
        data["effectiveDate"] = this.effectiveDate;
        data["expirationDate"] = this.expirationDate;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFirmRptBasisObj {
    firmId?: number | undefined;
    firmRptBasisID?: number | undefined;
    firmRptBasisDesc?: string | undefined;
    firmRptBasisTypeID?: number | undefined;
    firmRptBasisTypeDesc?: string | undefined;
    effectiveDate?: string | undefined;
    expirationDate?: string | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
}

export class FirmScopeConditionDto implements IFirmScopeConditionDto {
    scopeConditionTypeId?: number | undefined;
    lastModifiedBy?: number | undefined;
    restriction?: number;

    constructor(data?: IFirmScopeConditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scopeConditionTypeId = _data["scopeConditionTypeId"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.restriction = _data["restriction"];
        }
    }

    static fromJS(data: any): FirmScopeConditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmScopeConditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scopeConditionTypeId"] = this.scopeConditionTypeId;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["restriction"] = this.restriction;
        return data;
    }
}

export interface IFirmScopeConditionDto {
    scopeConditionTypeId?: number | undefined;
    lastModifiedBy?: number | undefined;
    restriction?: number;
}

export class FirmScopeDto implements IFirmScopeDto {
    firmScopeID?: number | undefined;
    scopeRevNum?: number | undefined;
    firmId?: number | undefined;
    objectID?: number | undefined;
    createdBy?: number | undefined;
    docReferenceID?: number | undefined;
    firmApplTypeID?: number | undefined;
    docIDs?: string | undefined;
    generalConditions?: string | undefined;
    effectiveDate?: Date | undefined;
    scopeCertificateLink?: string | undefined;
    applicationDate?: Date | undefined;
    licensedOrAuthorisedDate?: Date | undefined;

    constructor(data?: IFirmScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmScopeID = _data["firmScopeID"];
            this.scopeRevNum = _data["scopeRevNum"];
            this.firmId = _data["firmId"];
            this.objectID = _data["objectID"];
            this.createdBy = _data["createdBy"];
            this.docReferenceID = _data["docReferenceID"];
            this.firmApplTypeID = _data["firmApplTypeID"];
            this.docIDs = _data["docIDs"];
            this.generalConditions = _data["generalConditions"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.scopeCertificateLink = _data["scopeCertificateLink"];
            this.applicationDate = _data["applicationDate"] ? new Date(_data["applicationDate"].toString()) : <any>undefined;
            this.licensedOrAuthorisedDate = _data["licensedOrAuthorisedDate"] ? new Date(_data["licensedOrAuthorisedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FirmScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FirmScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmScopeID"] = this.firmScopeID;
        data["scopeRevNum"] = this.scopeRevNum;
        data["firmId"] = this.firmId;
        data["objectID"] = this.objectID;
        data["createdBy"] = this.createdBy;
        data["docReferenceID"] = this.docReferenceID;
        data["firmApplTypeID"] = this.firmApplTypeID;
        data["docIDs"] = this.docIDs;
        data["generalConditions"] = this.generalConditions;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["scopeCertificateLink"] = this.scopeCertificateLink;
        data["applicationDate"] = this.applicationDate ? this.applicationDate.toISOString() : <any>undefined;
        data["licensedOrAuthorisedDate"] = this.licensedOrAuthorisedDate ? this.licensedOrAuthorisedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFirmScopeDto {
    firmScopeID?: number | undefined;
    scopeRevNum?: number | undefined;
    firmId?: number | undefined;
    objectID?: number | undefined;
    createdBy?: number | undefined;
    docReferenceID?: number | undefined;
    firmApplTypeID?: number | undefined;
    docIDs?: string | undefined;
    generalConditions?: string | undefined;
    effectiveDate?: Date | undefined;
    scopeCertificateLink?: string | undefined;
    applicationDate?: Date | undefined;
    licensedOrAuthorisedDate?: Date | undefined;
}

export class FirmScopeDtoBaseResponse implements IFirmScopeDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: FirmScopeDto;

    constructor(data?: IFirmScopeDtoBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"] ? FirmScopeDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FirmScopeDtoBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FirmScopeDtoBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFirmScopeDtoBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: FirmScopeDto;
}

export class FirmSupervisionObj implements IFirmSupervisionObj {
    firmId?: number | undefined;
    notes?: string | undefined;
    noOfLocalStaff?: number | undefined;
    noOfTotalStaff?: number | undefined;
    firmOperatinalStatusId?: number | undefined;
    createdBy?: number | undefined;
    effectiveFromDate?: Date | undefined;

    constructor(data?: IFirmSupervisionObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.notes = _data["notes"];
            this.noOfLocalStaff = _data["noOfLocalStaff"];
            this.noOfTotalStaff = _data["noOfTotalStaff"];
            this.firmOperatinalStatusId = _data["firmOperatinalStatusId"];
            this.createdBy = _data["createdBy"];
            this.effectiveFromDate = _data["effectiveFromDate"] ? new Date(_data["effectiveFromDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FirmSupervisionObj {
        data = typeof data === 'object' ? data : {};
        let result = new FirmSupervisionObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["notes"] = this.notes;
        data["noOfLocalStaff"] = this.noOfLocalStaff;
        data["noOfTotalStaff"] = this.noOfTotalStaff;
        data["firmOperatinalStatusId"] = this.firmOperatinalStatusId;
        data["createdBy"] = this.createdBy;
        data["effectiveFromDate"] = this.effectiveFromDate ? this.effectiveFromDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFirmSupervisionObj {
    firmId?: number | undefined;
    notes?: string | undefined;
    noOfLocalStaff?: number | undefined;
    noOfTotalStaff?: number | undefined;
    firmOperatinalStatusId?: number | undefined;
    createdBy?: number | undefined;
    effectiveFromDate?: Date | undefined;
}

export class FirmUsersObj implements IFirmUsersObj {
    firmUsersID?: number | undefined;
    firmId?: number | undefined;
    userId?: number | undefined;
    firmUserassnLevelId?: number | undefined;
    firmUserAssnDateFrom?: Date | undefined;
    firmUserAssnDateTo?: Date | undefined;
    firmUserAssnReasonTypeID?: number | undefined;
    createdBy?: number | undefined;

    constructor(data?: IFirmUsersObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmUsersID = _data["firmUsersID"];
            this.firmId = _data["firmId"];
            this.userId = _data["userId"];
            this.firmUserassnLevelId = _data["firmUserassnLevelId"];
            this.firmUserAssnDateFrom = _data["firmUserAssnDateFrom"] ? new Date(_data["firmUserAssnDateFrom"].toString()) : <any>undefined;
            this.firmUserAssnDateTo = _data["firmUserAssnDateTo"] ? new Date(_data["firmUserAssnDateTo"].toString()) : <any>undefined;
            this.firmUserAssnReasonTypeID = _data["firmUserAssnReasonTypeID"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): FirmUsersObj {
        data = typeof data === 'object' ? data : {};
        let result = new FirmUsersObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmUsersID"] = this.firmUsersID;
        data["firmId"] = this.firmId;
        data["userId"] = this.userId;
        data["firmUserassnLevelId"] = this.firmUserassnLevelId;
        data["firmUserAssnDateFrom"] = this.firmUserAssnDateFrom ? this.firmUserAssnDateFrom.toISOString() : <any>undefined;
        data["firmUserAssnDateTo"] = this.firmUserAssnDateTo ? this.firmUserAssnDateTo.toISOString() : <any>undefined;
        data["firmUserAssnReasonTypeID"] = this.firmUserAssnReasonTypeID;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IFirmUsersObj {
    firmUsersID?: number | undefined;
    firmId?: number | undefined;
    userId?: number | undefined;
    firmUserassnLevelId?: number | undefined;
    firmUserAssnDateFrom?: Date | undefined;
    firmUserAssnDateTo?: Date | undefined;
    firmUserAssnReasonTypeID?: number | undefined;
    createdBy?: number | undefined;
}

export class FirmsAlphabeticallyObj implements IFirmsAlphabeticallyObj {
    firmId?: number | undefined;
    operationalStatusId?: number | undefined;
    authorisationCaseOfficerId?: number | undefined;
    supervisionCaseOfficerId?: number | undefined;
    qfcNumber?: string | undefined;
    userId?: number | undefined;
    relevantPerson?: number | undefined;
    csvAuthorisationStatus?: string | undefined;
    csvLicenseStatus?: string | undefined;
    csvLegalStatus?: string | undefined;
    csvPrudentialCategory?: string | undefined;
    csvSectorTypes?: string | undefined;
    csvFirmTypes?: string | undefined;
    startChar?: string | undefined;
    loginuserId?: number | undefined;
    csvFirmStatus?: string | undefined;
    csvSupCategories?: string | undefined;
    csvAuthorisationCategories?: string | undefined;

    constructor(data?: IFirmsAlphabeticallyObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.operationalStatusId = _data["operationalStatusId"];
            this.authorisationCaseOfficerId = _data["authorisationCaseOfficerId"];
            this.supervisionCaseOfficerId = _data["supervisionCaseOfficerId"];
            this.qfcNumber = _data["qfcNumber"];
            this.userId = _data["userId"];
            this.relevantPerson = _data["relevantPerson"];
            this.csvAuthorisationStatus = _data["csvAuthorisationStatus"];
            this.csvLicenseStatus = _data["csvLicenseStatus"];
            this.csvLegalStatus = _data["csvLegalStatus"];
            this.csvPrudentialCategory = _data["csvPrudentialCategory"];
            this.csvSectorTypes = _data["csvSectorTypes"];
            this.csvFirmTypes = _data["csvFirmTypes"];
            this.startChar = _data["startChar"];
            this.loginuserId = _data["loginuserId"];
            this.csvFirmStatus = _data["csvFirmStatus"];
            this.csvSupCategories = _data["csvSupCategories"];
            this.csvAuthorisationCategories = _data["csvAuthorisationCategories"];
        }
    }

    static fromJS(data: any): FirmsAlphabeticallyObj {
        data = typeof data === 'object' ? data : {};
        let result = new FirmsAlphabeticallyObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["operationalStatusId"] = this.operationalStatusId;
        data["authorisationCaseOfficerId"] = this.authorisationCaseOfficerId;
        data["supervisionCaseOfficerId"] = this.supervisionCaseOfficerId;
        data["qfcNumber"] = this.qfcNumber;
        data["userId"] = this.userId;
        data["relevantPerson"] = this.relevantPerson;
        data["csvAuthorisationStatus"] = this.csvAuthorisationStatus;
        data["csvLicenseStatus"] = this.csvLicenseStatus;
        data["csvLegalStatus"] = this.csvLegalStatus;
        data["csvPrudentialCategory"] = this.csvPrudentialCategory;
        data["csvSectorTypes"] = this.csvSectorTypes;
        data["csvFirmTypes"] = this.csvFirmTypes;
        data["startChar"] = this.startChar;
        data["loginuserId"] = this.loginuserId;
        data["csvFirmStatus"] = this.csvFirmStatus;
        data["csvSupCategories"] = this.csvSupCategories;
        data["csvAuthorisationCategories"] = this.csvAuthorisationCategories;
        return data;
    }
}

export interface IFirmsAlphabeticallyObj {
    firmId?: number | undefined;
    operationalStatusId?: number | undefined;
    authorisationCaseOfficerId?: number | undefined;
    supervisionCaseOfficerId?: number | undefined;
    qfcNumber?: string | undefined;
    userId?: number | undefined;
    relevantPerson?: number | undefined;
    csvAuthorisationStatus?: string | undefined;
    csvLicenseStatus?: string | undefined;
    csvLegalStatus?: string | undefined;
    csvPrudentialCategory?: string | undefined;
    csvSectorTypes?: string | undefined;
    csvFirmTypes?: string | undefined;
    startChar?: string | undefined;
    loginuserId?: number | undefined;
    csvFirmStatus?: string | undefined;
    csvSupCategories?: string | undefined;
    csvAuthorisationCategories?: string | undefined;
}

export class InsertDocObj implements IInsertDocObj {
    userId?: number | undefined;
    docID?: number | undefined;
    referenceNumber?: string | undefined;
    fileName?: string | undefined;
    fileNumber?: string | undefined;
    firmId?: number | undefined;
    otherFirm?: string | undefined;
    docTypeID?: number | undefined;
    loggedBy?: number | undefined;
    loggedDate?: Date | undefined;
    receivedBy?: number | undefined;
    receivedDate?: Date | undefined;
    docRecieptMethodID?: number | undefined;
    checkPrimaryDocID?: boolean | undefined;
    fileLocation?: string | undefined;
    docAttributeID?: number | undefined;
    intranetGuid?: string | undefined;
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    docSubType?: number | undefined;

    constructor(data?: IInsertDocObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.docID = _data["docID"];
            this.referenceNumber = _data["referenceNumber"];
            this.fileName = _data["fileName"];
            this.fileNumber = _data["fileNumber"];
            this.firmId = _data["firmId"];
            this.otherFirm = _data["otherFirm"];
            this.docTypeID = _data["docTypeID"];
            this.loggedBy = _data["loggedBy"];
            this.loggedDate = _data["loggedDate"] ? new Date(_data["loggedDate"].toString()) : <any>undefined;
            this.receivedBy = _data["receivedBy"];
            this.receivedDate = _data["receivedDate"] ? new Date(_data["receivedDate"].toString()) : <any>undefined;
            this.docRecieptMethodID = _data["docRecieptMethodID"];
            this.checkPrimaryDocID = _data["checkPrimaryDocID"];
            this.fileLocation = _data["fileLocation"];
            this.docAttributeID = _data["docAttributeID"];
            this.intranetGuid = _data["intranetGuid"];
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.objectInstanceRevNum = _data["objectInstanceRevNum"];
            this.docSubType = _data["docSubType"];
        }
    }

    static fromJS(data: any): InsertDocObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertDocObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["docID"] = this.docID;
        data["referenceNumber"] = this.referenceNumber;
        data["fileName"] = this.fileName;
        data["fileNumber"] = this.fileNumber;
        data["firmId"] = this.firmId;
        data["otherFirm"] = this.otherFirm;
        data["docTypeID"] = this.docTypeID;
        data["loggedBy"] = this.loggedBy;
        data["loggedDate"] = this.loggedDate ? this.loggedDate.toISOString() : <any>undefined;
        data["receivedBy"] = this.receivedBy;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toISOString() : <any>undefined;
        data["docRecieptMethodID"] = this.docRecieptMethodID;
        data["checkPrimaryDocID"] = this.checkPrimaryDocID;
        data["fileLocation"] = this.fileLocation;
        data["docAttributeID"] = this.docAttributeID;
        data["intranetGuid"] = this.intranetGuid;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["objectInstanceRevNum"] = this.objectInstanceRevNum;
        data["docSubType"] = this.docSubType;
        return data;
    }
}

export interface IInsertDocObj {
    userId?: number | undefined;
    docID?: number | undefined;
    referenceNumber?: string | undefined;
    fileName?: string | undefined;
    fileNumber?: string | undefined;
    firmId?: number | undefined;
    otherFirm?: string | undefined;
    docTypeID?: number | undefined;
    loggedBy?: number | undefined;
    loggedDate?: Date | undefined;
    receivedBy?: number | undefined;
    receivedDate?: Date | undefined;
    docRecieptMethodID?: number | undefined;
    checkPrimaryDocID?: boolean | undefined;
    fileLocation?: string | undefined;
    docAttributeID?: number | undefined;
    intranetGuid?: string | undefined;
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    docSubType?: number | undefined;
}

export class InsertEmailObj implements IInsertEmailObj {
    userTo?: string | undefined;
    notifiedBy?: number | undefined;
    userCC?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    objID?: number | undefined;
    objInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;

    constructor(data?: IInsertEmailObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userTo = _data["userTo"];
            this.notifiedBy = _data["notifiedBy"];
            this.userCC = _data["userCC"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.objID = _data["objID"];
            this.objInstanceID = _data["objInstanceID"];
            this.objectInstanceRevNum = _data["objectInstanceRevNum"];
        }
    }

    static fromJS(data: any): InsertEmailObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertEmailObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userTo"] = this.userTo;
        data["notifiedBy"] = this.notifiedBy;
        data["userCC"] = this.userCC;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["objID"] = this.objID;
        data["objInstanceID"] = this.objInstanceID;
        data["objectInstanceRevNum"] = this.objectInstanceRevNum;
        return data;
    }
}

export interface IInsertEmailObj {
    userTo?: string | undefined;
    notifiedBy?: number | undefined;
    userCC?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    objID?: number | undefined;
    objInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
}

export class InsertExtNotObj implements IInsertExtNotObj {
    extNotificationID?: number | undefined;
    notificationSubject?: string | undefined;
    notificationEmailBody?: string | undefined;
    notificationEmailTo?: string | undefined;
    notificationEmailCC?: string | undefined;
    createdBy?: number | undefined;
    notificationProcessed?: number | undefined;

    constructor(data?: IInsertExtNotObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.extNotificationID = _data["extNotificationID"];
            this.notificationSubject = _data["notificationSubject"];
            this.notificationEmailBody = _data["notificationEmailBody"];
            this.notificationEmailTo = _data["notificationEmailTo"];
            this.notificationEmailCC = _data["notificationEmailCC"];
            this.createdBy = _data["createdBy"];
            this.notificationProcessed = _data["notificationProcessed"];
        }
    }

    static fromJS(data: any): InsertExtNotObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertExtNotObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extNotificationID"] = this.extNotificationID;
        data["notificationSubject"] = this.notificationSubject;
        data["notificationEmailBody"] = this.notificationEmailBody;
        data["notificationEmailTo"] = this.notificationEmailTo;
        data["notificationEmailCC"] = this.notificationEmailCC;
        data["createdBy"] = this.createdBy;
        data["notificationProcessed"] = this.notificationProcessed;
        return data;
    }
}

export interface IInsertExtNotObj {
    extNotificationID?: number | undefined;
    notificationSubject?: string | undefined;
    notificationEmailBody?: string | undefined;
    notificationEmailTo?: string | undefined;
    notificationEmailCC?: string | undefined;
    createdBy?: number | undefined;
    notificationProcessed?: number | undefined;
}

export class InsertFirmFormObj implements IInsertFirmFormObj {
    firmDetails?: FirmDto;
    addressList?: AddressDto[] | undefined;
    objFirmNameHistory?: FirmNameHistoryDto;

    constructor(data?: IInsertFirmFormObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmDetails = _data["firmDetails"] ? FirmDto.fromJS(_data["firmDetails"]) : <any>undefined;
            if (Array.isArray(_data["addressList"])) {
                this.addressList = [] as any;
                for (let item of _data["addressList"])
                    this.addressList!.push(AddressDto.fromJS(item));
            }
            this.objFirmNameHistory = _data["objFirmNameHistory"] ? FirmNameHistoryDto.fromJS(_data["objFirmNameHistory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertFirmFormObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFirmFormObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmDetails"] = this.firmDetails ? this.firmDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.addressList)) {
            data["addressList"] = [];
            for (let item of this.addressList)
                data["addressList"].push(item.toJSON());
        }
        data["objFirmNameHistory"] = this.objFirmNameHistory ? this.objFirmNameHistory.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInsertFirmFormObj {
    firmDetails?: FirmDto;
    addressList?: AddressDto[] | undefined;
    objFirmNameHistory?: FirmNameHistoryDto;
}

export class InsertFirmParamsObj implements IInsertFirmParamsObj {
    firmApplID?: number | undefined;
    firmId?: number | undefined;
    firmApplTypeID?: number | undefined;
    firmApplDate?: Date | undefined;
    firmApplStatusID?: number | undefined;
    loginuserId?: number | undefined;
    output?: number | undefined;

    constructor(data?: IInsertFirmParamsObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmApplID = _data["firmApplID"];
            this.firmId = _data["firmId"];
            this.firmApplTypeID = _data["firmApplTypeID"];
            this.firmApplDate = _data["firmApplDate"] ? new Date(_data["firmApplDate"].toString()) : <any>undefined;
            this.firmApplStatusID = _data["firmApplStatusID"];
            this.loginuserId = _data["loginuserId"];
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): InsertFirmParamsObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFirmParamsObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmApplID"] = this.firmApplID;
        data["firmId"] = this.firmId;
        data["firmApplTypeID"] = this.firmApplTypeID;
        data["firmApplDate"] = this.firmApplDate ? this.firmApplDate.toISOString() : <any>undefined;
        data["firmApplStatusID"] = this.firmApplStatusID;
        data["loginuserId"] = this.loginuserId;
        data["output"] = this.output;
        return data;
    }
}

export interface IInsertFirmParamsObj {
    firmApplID?: number | undefined;
    firmId?: number | undefined;
    firmApplTypeID?: number | undefined;
    firmApplDate?: Date | undefined;
    firmApplStatusID?: number | undefined;
    loginuserId?: number | undefined;
    output?: number | undefined;
}

export class InsertFirmRMPObj implements IInsertFirmRMPObj {
    firmRMPID?: number | undefined;
    firmId?: number | undefined;
    dateFirmAgreedOn?: Date | undefined;
    agreedBy?: string | undefined;
    createdBy?: number | undefined;
    draftRMPDate?: Date | undefined;
    firmRMPTypeID?: number | undefined;

    constructor(data?: IInsertFirmRMPObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRMPID = _data["firmRMPID"];
            this.firmId = _data["firmId"];
            this.dateFirmAgreedOn = _data["dateFirmAgreedOn"] ? new Date(_data["dateFirmAgreedOn"].toString()) : <any>undefined;
            this.agreedBy = _data["agreedBy"];
            this.createdBy = _data["createdBy"];
            this.draftRMPDate = _data["draftRMPDate"] ? new Date(_data["draftRMPDate"].toString()) : <any>undefined;
            this.firmRMPTypeID = _data["firmRMPTypeID"];
        }
    }

    static fromJS(data: any): InsertFirmRMPObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFirmRMPObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRMPID"] = this.firmRMPID;
        data["firmId"] = this.firmId;
        data["dateFirmAgreedOn"] = this.dateFirmAgreedOn ? this.dateFirmAgreedOn.toISOString() : <any>undefined;
        data["agreedBy"] = this.agreedBy;
        data["createdBy"] = this.createdBy;
        data["draftRMPDate"] = this.draftRMPDate ? this.draftRMPDate.toISOString() : <any>undefined;
        data["firmRMPTypeID"] = this.firmRMPTypeID;
        return data;
    }
}

export interface IInsertFirmRMPObj {
    firmRMPID?: number | undefined;
    firmId?: number | undefined;
    dateFirmAgreedOn?: Date | undefined;
    agreedBy?: string | undefined;
    createdBy?: number | undefined;
    draftRMPDate?: Date | undefined;
    firmRMPTypeID?: number | undefined;
}

export class InsertFirmRiskObj implements IInsertFirmRiskObj {
    firmRiskID?: number | undefined;
    firmRiskRevNumber?: number | undefined;
    firmRMPID?: number | undefined;
    firmRiskNumber?: string | undefined;
    firmRiskIdentifiedDate?: Date | undefined;
    firmRiskIdentificationMethodTypeID?: number | undefined;
    firmRiskGroupTypeID?: number | undefined;
    firmRiskFactorTypeID?: number | undefined;
    firmRiskDesc?: string | undefined;
    createdBy?: number | undefined;
    firmRiskPriorityTypeID?: number | undefined;
    outcome?: string | undefined;

    constructor(data?: IInsertFirmRiskObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRiskID = _data["firmRiskID"];
            this.firmRiskRevNumber = _data["firmRiskRevNumber"];
            this.firmRMPID = _data["firmRMPID"];
            this.firmRiskNumber = _data["firmRiskNumber"];
            this.firmRiskIdentifiedDate = _data["firmRiskIdentifiedDate"] ? new Date(_data["firmRiskIdentifiedDate"].toString()) : <any>undefined;
            this.firmRiskIdentificationMethodTypeID = _data["firmRiskIdentificationMethodTypeID"];
            this.firmRiskGroupTypeID = _data["firmRiskGroupTypeID"];
            this.firmRiskFactorTypeID = _data["firmRiskFactorTypeID"];
            this.firmRiskDesc = _data["firmRiskDesc"];
            this.createdBy = _data["createdBy"];
            this.firmRiskPriorityTypeID = _data["firmRiskPriorityTypeID"];
            this.outcome = _data["outcome"];
        }
    }

    static fromJS(data: any): InsertFirmRiskObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFirmRiskObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRiskID"] = this.firmRiskID;
        data["firmRiskRevNumber"] = this.firmRiskRevNumber;
        data["firmRMPID"] = this.firmRMPID;
        data["firmRiskNumber"] = this.firmRiskNumber;
        data["firmRiskIdentifiedDate"] = this.firmRiskIdentifiedDate ? this.firmRiskIdentifiedDate.toISOString() : <any>undefined;
        data["firmRiskIdentificationMethodTypeID"] = this.firmRiskIdentificationMethodTypeID;
        data["firmRiskGroupTypeID"] = this.firmRiskGroupTypeID;
        data["firmRiskFactorTypeID"] = this.firmRiskFactorTypeID;
        data["firmRiskDesc"] = this.firmRiskDesc;
        data["createdBy"] = this.createdBy;
        data["firmRiskPriorityTypeID"] = this.firmRiskPriorityTypeID;
        data["outcome"] = this.outcome;
        return data;
    }
}

export interface IInsertFirmRiskObj {
    firmRiskID?: number | undefined;
    firmRiskRevNumber?: number | undefined;
    firmRMPID?: number | undefined;
    firmRiskNumber?: string | undefined;
    firmRiskIdentifiedDate?: Date | undefined;
    firmRiskIdentificationMethodTypeID?: number | undefined;
    firmRiskGroupTypeID?: number | undefined;
    firmRiskFactorTypeID?: number | undefined;
    firmRiskDesc?: string | undefined;
    createdBy?: number | undefined;
    firmRiskPriorityTypeID?: number | undefined;
    outcome?: string | undefined;
}

export class InsertFirmRptAdminFee implements IInsertFirmRptAdminFee {
    firmRptAdminFeeID?: number | undefined;
    firmRptSchItemID?: number | undefined;
    feeImposed?: boolean | undefined;
    calculatedAmount?: string | undefined;
    imposedAmount?: string | undefined;
    recommendation?: string | undefined;
    justification?: string | undefined;
    objectWFStatusID?: number | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    objectId?: number | undefined;
    firmRptReviewItemID?: number | undefined;
    adminFeeRateID?: number | undefined;
    calculatedAmountCurrencyTypeID?: number | undefined;
    imposedAmountCurrencyTypeID?: number | undefined;

    constructor(data?: IInsertFirmRptAdminFee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRptAdminFeeID = _data["firmRptAdminFeeID"];
            this.firmRptSchItemID = _data["firmRptSchItemID"];
            this.feeImposed = _data["feeImposed"];
            this.calculatedAmount = _data["calculatedAmount"];
            this.imposedAmount = _data["imposedAmount"];
            this.recommendation = _data["recommendation"];
            this.justification = _data["justification"];
            this.objectWFStatusID = _data["objectWFStatusID"];
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.objectId = _data["objectId"];
            this.firmRptReviewItemID = _data["firmRptReviewItemID"];
            this.adminFeeRateID = _data["adminFeeRateID"];
            this.calculatedAmountCurrencyTypeID = _data["calculatedAmountCurrencyTypeID"];
            this.imposedAmountCurrencyTypeID = _data["imposedAmountCurrencyTypeID"];
        }
    }

    static fromJS(data: any): InsertFirmRptAdminFee {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFirmRptAdminFee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRptAdminFeeID"] = this.firmRptAdminFeeID;
        data["firmRptSchItemID"] = this.firmRptSchItemID;
        data["feeImposed"] = this.feeImposed;
        data["calculatedAmount"] = this.calculatedAmount;
        data["imposedAmount"] = this.imposedAmount;
        data["recommendation"] = this.recommendation;
        data["justification"] = this.justification;
        data["objectWFStatusID"] = this.objectWFStatusID;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["objectId"] = this.objectId;
        data["firmRptReviewItemID"] = this.firmRptReviewItemID;
        data["adminFeeRateID"] = this.adminFeeRateID;
        data["calculatedAmountCurrencyTypeID"] = this.calculatedAmountCurrencyTypeID;
        data["imposedAmountCurrencyTypeID"] = this.imposedAmountCurrencyTypeID;
        return data;
    }
}

export interface IInsertFirmRptAdminFee {
    firmRptAdminFeeID?: number | undefined;
    firmRptSchItemID?: number | undefined;
    feeImposed?: boolean | undefined;
    calculatedAmount?: string | undefined;
    imposedAmount?: string | undefined;
    recommendation?: string | undefined;
    justification?: string | undefined;
    objectWFStatusID?: number | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    objectId?: number | undefined;
    firmRptReviewItemID?: number | undefined;
    adminFeeRateID?: number | undefined;
    calculatedAmountCurrencyTypeID?: number | undefined;
    imposedAmountCurrencyTypeID?: number | undefined;
}

export class InsertFirmRptObj implements IInsertFirmRptObj {
    firmRptSchItemID?: number | undefined;
    extNotificationID?: number | undefined;
    createdBy?: number | undefined;

    constructor(data?: IInsertFirmRptObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRptSchItemID = _data["firmRptSchItemID"];
            this.extNotificationID = _data["extNotificationID"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): InsertFirmRptObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFirmRptObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRptSchItemID"] = this.firmRptSchItemID;
        data["extNotificationID"] = this.extNotificationID;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IInsertFirmRptObj {
    firmRptSchItemID?: number | undefined;
    extNotificationID?: number | undefined;
    createdBy?: number | undefined;
}

export class InsertJournalObj implements IInsertJournalObj {
    supervisionJournalID?: number | undefined;
    firmId?: number | undefined;
    journalEntryTypeID?: number | undefined;
    entryBy?: number | undefined;
    entryDate?: Date | undefined;
    entryTitle?: string | undefined;
    entryNotes?: string | undefined;
    createdBy?: number | undefined;

    constructor(data?: IInsertJournalObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supervisionJournalID = _data["supervisionJournalID"];
            this.firmId = _data["firmId"];
            this.journalEntryTypeID = _data["journalEntryTypeID"];
            this.entryBy = _data["entryBy"];
            this.entryDate = _data["entryDate"] ? new Date(_data["entryDate"].toString()) : <any>undefined;
            this.entryTitle = _data["entryTitle"];
            this.entryNotes = _data["entryNotes"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): InsertJournalObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertJournalObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supervisionJournalID"] = this.supervisionJournalID;
        data["firmId"] = this.firmId;
        data["journalEntryTypeID"] = this.journalEntryTypeID;
        data["entryBy"] = this.entryBy;
        data["entryDate"] = this.entryDate ? this.entryDate.toISOString() : <any>undefined;
        data["entryTitle"] = this.entryTitle;
        data["entryNotes"] = this.entryNotes;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IInsertJournalObj {
    supervisionJournalID?: number | undefined;
    firmId?: number | undefined;
    journalEntryTypeID?: number | undefined;
    entryBy?: number | undefined;
    entryDate?: Date | undefined;
    entryTitle?: string | undefined;
    entryNotes?: string | undefined;
    createdBy?: number | undefined;
}

export class InsertLogFormObj implements IInsertLogFormObj {
    userId?: number | undefined;
    docID?: number | undefined;
    referenceNumber?: string | undefined;
    fileName?: string | undefined;
    fileNumber?: string | undefined;
    firmId?: number | undefined;
    otherFirm?: string | undefined;
    docTypeID?: number | undefined;
    loggedBy?: number | undefined;
    loggedDate?: Date | undefined;
    receivedBy?: number | undefined;
    receivedDate?: Date | undefined;
    docRecieptMethodID?: number | undefined;
    checkPrimaryDocID?: boolean | undefined;
    fileLocation?: string | undefined;
    docAttributeID?: number | undefined;
    intranetGuid?: string | undefined;

    constructor(data?: IInsertLogFormObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.docID = _data["docID"];
            this.referenceNumber = _data["referenceNumber"];
            this.fileName = _data["fileName"];
            this.fileNumber = _data["fileNumber"];
            this.firmId = _data["firmId"];
            this.otherFirm = _data["otherFirm"];
            this.docTypeID = _data["docTypeID"];
            this.loggedBy = _data["loggedBy"];
            this.loggedDate = _data["loggedDate"] ? new Date(_data["loggedDate"].toString()) : <any>undefined;
            this.receivedBy = _data["receivedBy"];
            this.receivedDate = _data["receivedDate"] ? new Date(_data["receivedDate"].toString()) : <any>undefined;
            this.docRecieptMethodID = _data["docRecieptMethodID"];
            this.checkPrimaryDocID = _data["checkPrimaryDocID"];
            this.fileLocation = _data["fileLocation"];
            this.docAttributeID = _data["docAttributeID"];
            this.intranetGuid = _data["intranetGuid"];
        }
    }

    static fromJS(data: any): InsertLogFormObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertLogFormObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["docID"] = this.docID;
        data["referenceNumber"] = this.referenceNumber;
        data["fileName"] = this.fileName;
        data["fileNumber"] = this.fileNumber;
        data["firmId"] = this.firmId;
        data["otherFirm"] = this.otherFirm;
        data["docTypeID"] = this.docTypeID;
        data["loggedBy"] = this.loggedBy;
        data["loggedDate"] = this.loggedDate ? this.loggedDate.toISOString() : <any>undefined;
        data["receivedBy"] = this.receivedBy;
        data["receivedDate"] = this.receivedDate ? this.receivedDate.toISOString() : <any>undefined;
        data["docRecieptMethodID"] = this.docRecieptMethodID;
        data["checkPrimaryDocID"] = this.checkPrimaryDocID;
        data["fileLocation"] = this.fileLocation;
        data["docAttributeID"] = this.docAttributeID;
        data["intranetGuid"] = this.intranetGuid;
        return data;
    }
}

export interface IInsertLogFormObj {
    userId?: number | undefined;
    docID?: number | undefined;
    referenceNumber?: string | undefined;
    fileName?: string | undefined;
    fileNumber?: string | undefined;
    firmId?: number | undefined;
    otherFirm?: string | undefined;
    docTypeID?: number | undefined;
    loggedBy?: number | undefined;
    loggedDate?: Date | undefined;
    receivedBy?: number | undefined;
    receivedDate?: Date | undefined;
    docRecieptMethodID?: number | undefined;
    checkPrimaryDocID?: boolean | undefined;
    fileLocation?: string | undefined;
    docAttributeID?: number | undefined;
    intranetGuid?: string | undefined;
}

export class InsertObjectWFObj implements IInsertObjectWFObj {
    objectWFStatusId?: number | undefined;
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    objectWFStatusTypeID?: number | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;

    constructor(data?: IInsertObjectWFObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectWFStatusId = _data["objectWFStatusId"];
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.objectInstanceRevNum = _data["objectInstanceRevNum"];
            this.objectWFStatusTypeID = _data["objectWFStatusTypeID"];
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): InsertObjectWFObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertObjectWFObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectWFStatusId"] = this.objectWFStatusId;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["objectInstanceRevNum"] = this.objectInstanceRevNum;
        data["objectWFStatusTypeID"] = this.objectWFStatusTypeID;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IInsertObjectWFObj {
    objectWFStatusId?: number | undefined;
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    objectWFStatusTypeID?: number | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
}

export class InsertOtherEntityObj implements IInsertOtherEntityObj {
    otherEntityID?: number | undefined;
    otherEntityName?: string | undefined;
    dateOfIncorporation?: Date | undefined;
    legalStatusTypeID?: number | undefined;
    placeOfIncorporation?: string | undefined;
    countryOfIncorporation?: number | undefined;
    registeredNumber?: string | undefined;
    webSiteAddress?: string | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    isAuditor?: number | undefined;
    isCompanyRegulated?: boolean | undefined;
    additionalDetails?: string | undefined;
    isParentController?: boolean | undefined;
    isPublicallyTraded?: boolean | undefined;
    areAnyUBOs?: boolean | undefined;
    controllerInfo?: string | undefined;
    output?: number | undefined;

    constructor(data?: IInsertOtherEntityObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.otherEntityID = _data["otherEntityID"];
            this.otherEntityName = _data["otherEntityName"];
            this.dateOfIncorporation = _data["dateOfIncorporation"] ? new Date(_data["dateOfIncorporation"].toString()) : <any>undefined;
            this.legalStatusTypeID = _data["legalStatusTypeID"];
            this.placeOfIncorporation = _data["placeOfIncorporation"];
            this.countryOfIncorporation = _data["countryOfIncorporation"];
            this.registeredNumber = _data["registeredNumber"];
            this.webSiteAddress = _data["webSiteAddress"];
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.isAuditor = _data["isAuditor"];
            this.isCompanyRegulated = _data["isCompanyRegulated"];
            this.additionalDetails = _data["additionalDetails"];
            this.isParentController = _data["isParentController"];
            this.isPublicallyTraded = _data["isPublicallyTraded"];
            this.areAnyUBOs = _data["areAnyUBOs"];
            this.controllerInfo = _data["controllerInfo"];
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): InsertOtherEntityObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOtherEntityObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["otherEntityID"] = this.otherEntityID;
        data["otherEntityName"] = this.otherEntityName;
        data["dateOfIncorporation"] = this.dateOfIncorporation ? this.dateOfIncorporation.toISOString() : <any>undefined;
        data["legalStatusTypeID"] = this.legalStatusTypeID;
        data["placeOfIncorporation"] = this.placeOfIncorporation;
        data["countryOfIncorporation"] = this.countryOfIncorporation;
        data["registeredNumber"] = this.registeredNumber;
        data["webSiteAddress"] = this.webSiteAddress;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["isAuditor"] = this.isAuditor;
        data["isCompanyRegulated"] = this.isCompanyRegulated;
        data["additionalDetails"] = this.additionalDetails;
        data["isParentController"] = this.isParentController;
        data["isPublicallyTraded"] = this.isPublicallyTraded;
        data["areAnyUBOs"] = this.areAnyUBOs;
        data["controllerInfo"] = this.controllerInfo;
        data["output"] = this.output;
        return data;
    }
}

export interface IInsertOtherEntityObj {
    otherEntityID?: number | undefined;
    otherEntityName?: string | undefined;
    dateOfIncorporation?: Date | undefined;
    legalStatusTypeID?: number | undefined;
    placeOfIncorporation?: string | undefined;
    countryOfIncorporation?: number | undefined;
    registeredNumber?: string | undefined;
    webSiteAddress?: string | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    isAuditor?: number | undefined;
    isCompanyRegulated?: boolean | undefined;
    additionalDetails?: string | undefined;
    isParentController?: boolean | undefined;
    isPublicallyTraded?: boolean | undefined;
    areAnyUBOs?: boolean | undefined;
    controllerInfo?: string | undefined;
    output?: number | undefined;
}

export class InsertRelatedEntityObj implements IInsertRelatedEntityObj {
    relatedEntityID?: number | undefined;
    firmId?: number | undefined;
    entityTypeID?: number | undefined;
    entitySubTypeID?: number | undefined;
    entityID?: number | undefined;
    relatedEntityTypeID?: number | undefined;
    relatedEntityEntityID?: number | undefined;
    controllerControlTypeID?: number | undefined;
    numOfShares?: number | undefined;
    pctOfShares?: number | undefined;
    majorityStockHolder?: boolean | undefined;
    assnDateFrom?: Date | undefined;
    assnDateTo?: Date | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    output?: number | undefined;

    constructor(data?: IInsertRelatedEntityObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.relatedEntityID = _data["relatedEntityID"];
            this.firmId = _data["firmId"];
            this.entityTypeID = _data["entityTypeID"];
            this.entitySubTypeID = _data["entitySubTypeID"];
            this.entityID = _data["entityID"];
            this.relatedEntityTypeID = _data["relatedEntityTypeID"];
            this.relatedEntityEntityID = _data["relatedEntityEntityID"];
            this.controllerControlTypeID = _data["controllerControlTypeID"];
            this.numOfShares = _data["numOfShares"];
            this.pctOfShares = _data["pctOfShares"];
            this.majorityStockHolder = _data["majorityStockHolder"];
            this.assnDateFrom = _data["assnDateFrom"] ? new Date(_data["assnDateFrom"].toString()) : <any>undefined;
            this.assnDateTo = _data["assnDateTo"] ? new Date(_data["assnDateTo"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): InsertRelatedEntityObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertRelatedEntityObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["relatedEntityID"] = this.relatedEntityID;
        data["firmId"] = this.firmId;
        data["entityTypeID"] = this.entityTypeID;
        data["entitySubTypeID"] = this.entitySubTypeID;
        data["entityID"] = this.entityID;
        data["relatedEntityTypeID"] = this.relatedEntityTypeID;
        data["relatedEntityEntityID"] = this.relatedEntityEntityID;
        data["controllerControlTypeID"] = this.controllerControlTypeID;
        data["numOfShares"] = this.numOfShares;
        data["pctOfShares"] = this.pctOfShares;
        data["majorityStockHolder"] = this.majorityStockHolder;
        data["assnDateFrom"] = this.assnDateFrom ? this.assnDateFrom.toISOString() : <any>undefined;
        data["assnDateTo"] = this.assnDateTo ? this.assnDateTo.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["output"] = this.output;
        return data;
    }
}

export interface IInsertRelatedEntityObj {
    relatedEntityID?: number | undefined;
    firmId?: number | undefined;
    entityTypeID?: number | undefined;
    entitySubTypeID?: number | undefined;
    entityID?: number | undefined;
    relatedEntityTypeID?: number | undefined;
    relatedEntityEntityID?: number | undefined;
    controllerControlTypeID?: number | undefined;
    numOfShares?: number | undefined;
    pctOfShares?: number | undefined;
    majorityStockHolder?: boolean | undefined;
    assnDateFrom?: Date | undefined;
    assnDateTo?: Date | undefined;
    createdBy?: number | undefined;
    lastModifiedBy?: number | undefined;
    output?: number | undefined;
}

export class InsertRptSignObj implements IInsertRptSignObj {
    firmRptSignatoryID?: number | undefined;
    firmId?: number | undefined;
    docTypeID?: number | undefined;
    contactID?: number | undefined;
    effectiveDate?: Date | undefined;
    expirationDate?: Date | undefined;
    signOffSeqNo?: number | undefined;
    groupSignOff?: boolean | undefined;
    comments?: string | undefined;
    modifiedBy?: number | undefined;

    constructor(data?: IInsertRptSignObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRptSignatoryID = _data["firmRptSignatoryID"];
            this.firmId = _data["firmId"];
            this.docTypeID = _data["docTypeID"];
            this.contactID = _data["contactID"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.signOffSeqNo = _data["signOffSeqNo"];
            this.groupSignOff = _data["groupSignOff"];
            this.comments = _data["comments"];
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): InsertRptSignObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertRptSignObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRptSignatoryID"] = this.firmRptSignatoryID;
        data["firmId"] = this.firmId;
        data["docTypeID"] = this.docTypeID;
        data["contactID"] = this.contactID;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["signOffSeqNo"] = this.signOffSeqNo;
        data["groupSignOff"] = this.groupSignOff;
        data["comments"] = this.comments;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IInsertRptSignObj {
    firmRptSignatoryID?: number | undefined;
    firmId?: number | undefined;
    docTypeID?: number | undefined;
    contactID?: number | undefined;
    effectiveDate?: Date | undefined;
    expirationDate?: Date | undefined;
    signOffSeqNo?: number | undefined;
    groupSignOff?: boolean | undefined;
    comments?: string | undefined;
    modifiedBy?: number | undefined;
}

export class InsertSupervisionObj implements IInsertSupervisionObj {
    journalSubjectAssnID?: number | undefined;
    supervisionJournalID?: number | undefined;
    journalSubjectTypeID?: number | undefined;
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    journalSubjectOtherDesc?: string | undefined;
    createdBy?: number | undefined;

    constructor(data?: IInsertSupervisionObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.journalSubjectAssnID = _data["journalSubjectAssnID"];
            this.supervisionJournalID = _data["supervisionJournalID"];
            this.journalSubjectTypeID = _data["journalSubjectTypeID"];
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.journalSubjectOtherDesc = _data["journalSubjectOtherDesc"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): InsertSupervisionObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertSupervisionObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["journalSubjectAssnID"] = this.journalSubjectAssnID;
        data["supervisionJournalID"] = this.supervisionJournalID;
        data["journalSubjectTypeID"] = this.journalSubjectTypeID;
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["journalSubjectOtherDesc"] = this.journalSubjectOtherDesc;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IInsertSupervisionObj {
    journalSubjectAssnID?: number | undefined;
    supervisionJournalID?: number | undefined;
    journalSubjectTypeID?: number | undefined;
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    journalSubjectOtherDesc?: string | undefined;
    createdBy?: number | undefined;
}

export class InsertUpdateSupervisionObj implements IInsertUpdateSupervisionObj {
    firmSupervisionObj?: FirmSupervisionObj;
    firmClientClassificationObj?: FirmClientClassificationObj;
    rptBasisObj?: FirmRptBasisObj;

    constructor(data?: IInsertUpdateSupervisionObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmSupervisionObj = _data["firmSupervisionObj"] ? FirmSupervisionObj.fromJS(_data["firmSupervisionObj"]) : <any>undefined;
            this.firmClientClassificationObj = _data["firmClientClassificationObj"] ? FirmClientClassificationObj.fromJS(_data["firmClientClassificationObj"]) : <any>undefined;
            this.rptBasisObj = _data["rptBasisObj"] ? FirmRptBasisObj.fromJS(_data["rptBasisObj"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertUpdateSupervisionObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertUpdateSupervisionObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmSupervisionObj"] = this.firmSupervisionObj ? this.firmSupervisionObj.toJSON() : <any>undefined;
        data["firmClientClassificationObj"] = this.firmClientClassificationObj ? this.firmClientClassificationObj.toJSON() : <any>undefined;
        data["rptBasisObj"] = this.rptBasisObj ? this.rptBasisObj.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInsertUpdateSupervisionObj {
    firmSupervisionObj?: FirmSupervisionObj;
    firmClientClassificationObj?: FirmClientClassificationObj;
    rptBasisObj?: FirmRptBasisObj;
}

export class InsertUserRoles implements IInsertUserRoles {
    userId?: number | undefined;
    appRoleID?: number | undefined;
    appRoleEnabled?: boolean | undefined;
    effectiveDate?: Date | undefined;
    expirationDate?: Date | undefined;
    justification?: string | undefined;
    modifiedBy?: number | undefined;
    userRoleFirmTypeID?: number | undefined;
    csVfirmIds?: string | undefined;
    isValuesChanged?: boolean | undefined;
    output?: number | undefined;

    constructor(data?: IInsertUserRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.appRoleID = _data["appRoleID"];
            this.appRoleEnabled = _data["appRoleEnabled"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.justification = _data["justification"];
            this.modifiedBy = _data["modifiedBy"];
            this.userRoleFirmTypeID = _data["userRoleFirmTypeID"];
            this.csVfirmIds = _data["csVfirmIds"];
            this.isValuesChanged = _data["isValuesChanged"];
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): InsertUserRoles {
        data = typeof data === 'object' ? data : {};
        let result = new InsertUserRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["appRoleID"] = this.appRoleID;
        data["appRoleEnabled"] = this.appRoleEnabled;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["justification"] = this.justification;
        data["modifiedBy"] = this.modifiedBy;
        data["userRoleFirmTypeID"] = this.userRoleFirmTypeID;
        data["csVfirmIds"] = this.csVfirmIds;
        data["isValuesChanged"] = this.isValuesChanged;
        data["output"] = this.output;
        return data;
    }
}

export interface IInsertUserRoles {
    userId?: number | undefined;
    appRoleID?: number | undefined;
    appRoleEnabled?: boolean | undefined;
    effectiveDate?: Date | undefined;
    expirationDate?: Date | undefined;
    justification?: string | undefined;
    modifiedBy?: number | undefined;
    userRoleFirmTypeID?: number | undefined;
    csVfirmIds?: string | undefined;
    isValuesChanged?: boolean | undefined;
    output?: number | undefined;
}

export class InsertWaiverObj implements IInsertWaiverObj {
    waiverID?: number | undefined;
    waiverRevNum?: number | undefined;
    firmId?: number | undefined;
    waiverNumber?: string | undefined;
    waiverSourceTypeID?: number | undefined;
    waiverTypeID?: number | undefined;
    waiverStatusID?: number | undefined;
    waiverApplicationLink?: number | undefined;
    waiverNoticeLink?: number | undefined;
    waiverSubject?: string | undefined;
    existingWaiverID?: number | undefined;
    existingWaiverRevNum?: number | undefined;
    waiverPrecedentDecision?: boolean | undefined;
    waiverPreviousPrecedents?: string | undefined;
    waiverDetails?: string | undefined;
    firmGroundsForRecomd?: string | undefined;
    aiName?: string | undefined;
    aiApplicantRecomdLink?: string | undefined;
    waiverPubNoticeTypeID?: number | undefined;
    partialOrNotPubReason?: string | undefined;
    waiverReviewReason?: string | undefined;
    reviewMeetingDate?: Date | undefined;
    waiverRules?: string | undefined;
    waiverCondition?: string | undefined;
    waiverRecomdGrounds?: string | undefined;
    waiverRevocation?: string | undefined;
    waiverNoticeScheduleLink?: string | undefined;
    waiverEffectiveDate?: Date | undefined;
    waiverExpirationDate?: Date | undefined;
    objectWFStatusID?: number | undefined;
    waiverRecomdNoticeLink?: string | undefined;
    createdBy?: number | undefined;
    firmLevelOfBusiness?: string | undefined;
    waiverDecisionTypeID?: number | undefined;
    waiverStatusTypeID?: number | undefined;
    waiverStatusDate?: Date | undefined;
    ojectID?: number | undefined;
    firmApplStatusTypeID?: number | undefined;

    constructor(data?: IInsertWaiverObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.waiverID = _data["waiverID"];
            this.waiverRevNum = _data["waiverRevNum"];
            this.firmId = _data["firmId"];
            this.waiverNumber = _data["waiverNumber"];
            this.waiverSourceTypeID = _data["waiverSourceTypeID"];
            this.waiverTypeID = _data["waiverTypeID"];
            this.waiverStatusID = _data["waiverStatusID"];
            this.waiverApplicationLink = _data["waiverApplicationLink"];
            this.waiverNoticeLink = _data["waiverNoticeLink"];
            this.waiverSubject = _data["waiverSubject"];
            this.existingWaiverID = _data["existingWaiverID"];
            this.existingWaiverRevNum = _data["existingWaiverRevNum"];
            this.waiverPrecedentDecision = _data["waiverPrecedentDecision"];
            this.waiverPreviousPrecedents = _data["waiverPreviousPrecedents"];
            this.waiverDetails = _data["waiverDetails"];
            this.firmGroundsForRecomd = _data["firmGroundsForRecomd"];
            this.aiName = _data["aiName"];
            this.aiApplicantRecomdLink = _data["aiApplicantRecomdLink"];
            this.waiverPubNoticeTypeID = _data["waiverPubNoticeTypeID"];
            this.partialOrNotPubReason = _data["partialOrNotPubReason"];
            this.waiverReviewReason = _data["waiverReviewReason"];
            this.reviewMeetingDate = _data["reviewMeetingDate"] ? new Date(_data["reviewMeetingDate"].toString()) : <any>undefined;
            this.waiverRules = _data["waiverRules"];
            this.waiverCondition = _data["waiverCondition"];
            this.waiverRecomdGrounds = _data["waiverRecomdGrounds"];
            this.waiverRevocation = _data["waiverRevocation"];
            this.waiverNoticeScheduleLink = _data["waiverNoticeScheduleLink"];
            this.waiverEffectiveDate = _data["waiverEffectiveDate"] ? new Date(_data["waiverEffectiveDate"].toString()) : <any>undefined;
            this.waiverExpirationDate = _data["waiverExpirationDate"] ? new Date(_data["waiverExpirationDate"].toString()) : <any>undefined;
            this.objectWFStatusID = _data["objectWFStatusID"];
            this.waiverRecomdNoticeLink = _data["waiverRecomdNoticeLink"];
            this.createdBy = _data["createdBy"];
            this.firmLevelOfBusiness = _data["firmLevelOfBusiness"];
            this.waiverDecisionTypeID = _data["waiverDecisionTypeID"];
            this.waiverStatusTypeID = _data["waiverStatusTypeID"];
            this.waiverStatusDate = _data["waiverStatusDate"] ? new Date(_data["waiverStatusDate"].toString()) : <any>undefined;
            this.ojectID = _data["ojectID"];
            this.firmApplStatusTypeID = _data["firmApplStatusTypeID"];
        }
    }

    static fromJS(data: any): InsertWaiverObj {
        data = typeof data === 'object' ? data : {};
        let result = new InsertWaiverObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waiverID"] = this.waiverID;
        data["waiverRevNum"] = this.waiverRevNum;
        data["firmId"] = this.firmId;
        data["waiverNumber"] = this.waiverNumber;
        data["waiverSourceTypeID"] = this.waiverSourceTypeID;
        data["waiverTypeID"] = this.waiverTypeID;
        data["waiverStatusID"] = this.waiverStatusID;
        data["waiverApplicationLink"] = this.waiverApplicationLink;
        data["waiverNoticeLink"] = this.waiverNoticeLink;
        data["waiverSubject"] = this.waiverSubject;
        data["existingWaiverID"] = this.existingWaiverID;
        data["existingWaiverRevNum"] = this.existingWaiverRevNum;
        data["waiverPrecedentDecision"] = this.waiverPrecedentDecision;
        data["waiverPreviousPrecedents"] = this.waiverPreviousPrecedents;
        data["waiverDetails"] = this.waiverDetails;
        data["firmGroundsForRecomd"] = this.firmGroundsForRecomd;
        data["aiName"] = this.aiName;
        data["aiApplicantRecomdLink"] = this.aiApplicantRecomdLink;
        data["waiverPubNoticeTypeID"] = this.waiverPubNoticeTypeID;
        data["partialOrNotPubReason"] = this.partialOrNotPubReason;
        data["waiverReviewReason"] = this.waiverReviewReason;
        data["reviewMeetingDate"] = this.reviewMeetingDate ? this.reviewMeetingDate.toISOString() : <any>undefined;
        data["waiverRules"] = this.waiverRules;
        data["waiverCondition"] = this.waiverCondition;
        data["waiverRecomdGrounds"] = this.waiverRecomdGrounds;
        data["waiverRevocation"] = this.waiverRevocation;
        data["waiverNoticeScheduleLink"] = this.waiverNoticeScheduleLink;
        data["waiverEffectiveDate"] = this.waiverEffectiveDate ? this.waiverEffectiveDate.toISOString() : <any>undefined;
        data["waiverExpirationDate"] = this.waiverExpirationDate ? this.waiverExpirationDate.toISOString() : <any>undefined;
        data["objectWFStatusID"] = this.objectWFStatusID;
        data["waiverRecomdNoticeLink"] = this.waiverRecomdNoticeLink;
        data["createdBy"] = this.createdBy;
        data["firmLevelOfBusiness"] = this.firmLevelOfBusiness;
        data["waiverDecisionTypeID"] = this.waiverDecisionTypeID;
        data["waiverStatusTypeID"] = this.waiverStatusTypeID;
        data["waiverStatusDate"] = this.waiverStatusDate ? this.waiverStatusDate.toISOString() : <any>undefined;
        data["ojectID"] = this.ojectID;
        data["firmApplStatusTypeID"] = this.firmApplStatusTypeID;
        return data;
    }
}

export interface IInsertWaiverObj {
    waiverID?: number | undefined;
    waiverRevNum?: number | undefined;
    firmId?: number | undefined;
    waiverNumber?: string | undefined;
    waiverSourceTypeID?: number | undefined;
    waiverTypeID?: number | undefined;
    waiverStatusID?: number | undefined;
    waiverApplicationLink?: number | undefined;
    waiverNoticeLink?: number | undefined;
    waiverSubject?: string | undefined;
    existingWaiverID?: number | undefined;
    existingWaiverRevNum?: number | undefined;
    waiverPrecedentDecision?: boolean | undefined;
    waiverPreviousPrecedents?: string | undefined;
    waiverDetails?: string | undefined;
    firmGroundsForRecomd?: string | undefined;
    aiName?: string | undefined;
    aiApplicantRecomdLink?: string | undefined;
    waiverPubNoticeTypeID?: number | undefined;
    partialOrNotPubReason?: string | undefined;
    waiverReviewReason?: string | undefined;
    reviewMeetingDate?: Date | undefined;
    waiverRules?: string | undefined;
    waiverCondition?: string | undefined;
    waiverRecomdGrounds?: string | undefined;
    waiverRevocation?: string | undefined;
    waiverNoticeScheduleLink?: string | undefined;
    waiverEffectiveDate?: Date | undefined;
    waiverExpirationDate?: Date | undefined;
    objectWFStatusID?: number | undefined;
    waiverRecomdNoticeLink?: string | undefined;
    createdBy?: number | undefined;
    firmLevelOfBusiness?: string | undefined;
    waiverDecisionTypeID?: number | undefined;
    waiverStatusTypeID?: number | undefined;
    waiverStatusDate?: Date | undefined;
    ojectID?: number | undefined;
    firmApplStatusTypeID?: number | undefined;
}

export class InstertTasksObj implements IInstertTasksObj {
    objectWFTaskStatusID?: number | undefined;
    objectWFStatusID?: number | undefined;
    objectTaskTypeID?: number | undefined;
    objectWFTaskSeq?: number | undefined;
    wfTaskAssignedToUser?: number | undefined;
    wfTaskAssignedToRole?: number | undefined;
    wfTaskAssignedDate?: Date | undefined;
    wfTaskCompletedDate?: Date | undefined;
    wfTaskDueDate?: Date | undefined;
    objectWFStatusTypeID?: number | undefined;
    emailTo?: string | undefined;
    emailCC?: string | undefined;
    lastModifiedBy?: number | undefined;
    objectWFTaskStart?: boolean | undefined;
    objectWFTaskMandatory?: boolean | undefined;
    objectEditableFlag?: boolean | undefined;
    objectWFTaskDefsID?: number | undefined;
    completionEmailTO?: string | undefined;
    completionEmailCC?: string | undefined;
    completionAssignToUser?: number | undefined;
    completionAssignToRole?: number | undefined;
    taskInitiatedBy?: number | undefined;
    reasonforEscalation?: string | undefined;

    constructor(data?: IInstertTasksObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectWFTaskStatusID = _data["objectWFTaskStatusID"];
            this.objectWFStatusID = _data["objectWFStatusID"];
            this.objectTaskTypeID = _data["objectTaskTypeID"];
            this.objectWFTaskSeq = _data["objectWFTaskSeq"];
            this.wfTaskAssignedToUser = _data["wfTaskAssignedToUser"];
            this.wfTaskAssignedToRole = _data["wfTaskAssignedToRole"];
            this.wfTaskAssignedDate = _data["wfTaskAssignedDate"] ? new Date(_data["wfTaskAssignedDate"].toString()) : <any>undefined;
            this.wfTaskCompletedDate = _data["wfTaskCompletedDate"] ? new Date(_data["wfTaskCompletedDate"].toString()) : <any>undefined;
            this.wfTaskDueDate = _data["wfTaskDueDate"] ? new Date(_data["wfTaskDueDate"].toString()) : <any>undefined;
            this.objectWFStatusTypeID = _data["objectWFStatusTypeID"];
            this.emailTo = _data["emailTo"];
            this.emailCC = _data["emailCC"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.objectWFTaskStart = _data["objectWFTaskStart"];
            this.objectWFTaskMandatory = _data["objectWFTaskMandatory"];
            this.objectEditableFlag = _data["objectEditableFlag"];
            this.objectWFTaskDefsID = _data["objectWFTaskDefsID"];
            this.completionEmailTO = _data["completionEmailTO"];
            this.completionEmailCC = _data["completionEmailCC"];
            this.completionAssignToUser = _data["completionAssignToUser"];
            this.completionAssignToRole = _data["completionAssignToRole"];
            this.taskInitiatedBy = _data["taskInitiatedBy"];
            this.reasonforEscalation = _data["reasonforEscalation"];
        }
    }

    static fromJS(data: any): InstertTasksObj {
        data = typeof data === 'object' ? data : {};
        let result = new InstertTasksObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectWFTaskStatusID"] = this.objectWFTaskStatusID;
        data["objectWFStatusID"] = this.objectWFStatusID;
        data["objectTaskTypeID"] = this.objectTaskTypeID;
        data["objectWFTaskSeq"] = this.objectWFTaskSeq;
        data["wfTaskAssignedToUser"] = this.wfTaskAssignedToUser;
        data["wfTaskAssignedToRole"] = this.wfTaskAssignedToRole;
        data["wfTaskAssignedDate"] = this.wfTaskAssignedDate ? this.wfTaskAssignedDate.toISOString() : <any>undefined;
        data["wfTaskCompletedDate"] = this.wfTaskCompletedDate ? this.wfTaskCompletedDate.toISOString() : <any>undefined;
        data["wfTaskDueDate"] = this.wfTaskDueDate ? this.wfTaskDueDate.toISOString() : <any>undefined;
        data["objectWFStatusTypeID"] = this.objectWFStatusTypeID;
        data["emailTo"] = this.emailTo;
        data["emailCC"] = this.emailCC;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["objectWFTaskStart"] = this.objectWFTaskStart;
        data["objectWFTaskMandatory"] = this.objectWFTaskMandatory;
        data["objectEditableFlag"] = this.objectEditableFlag;
        data["objectWFTaskDefsID"] = this.objectWFTaskDefsID;
        data["completionEmailTO"] = this.completionEmailTO;
        data["completionEmailCC"] = this.completionEmailCC;
        data["completionAssignToUser"] = this.completionAssignToUser;
        data["completionAssignToRole"] = this.completionAssignToRole;
        data["taskInitiatedBy"] = this.taskInitiatedBy;
        data["reasonforEscalation"] = this.reasonforEscalation;
        return data;
    }
}

export interface IInstertTasksObj {
    objectWFTaskStatusID?: number | undefined;
    objectWFStatusID?: number | undefined;
    objectTaskTypeID?: number | undefined;
    objectWFTaskSeq?: number | undefined;
    wfTaskAssignedToUser?: number | undefined;
    wfTaskAssignedToRole?: number | undefined;
    wfTaskAssignedDate?: Date | undefined;
    wfTaskCompletedDate?: Date | undefined;
    wfTaskDueDate?: Date | undefined;
    objectWFStatusTypeID?: number | undefined;
    emailTo?: string | undefined;
    emailCC?: string | undefined;
    lastModifiedBy?: number | undefined;
    objectWFTaskStart?: boolean | undefined;
    objectWFTaskMandatory?: boolean | undefined;
    objectEditableFlag?: boolean | undefined;
    objectWFTaskDefsID?: number | undefined;
    completionEmailTO?: string | undefined;
    completionEmailCC?: string | undefined;
    completionAssignToUser?: number | undefined;
    completionAssignToRole?: number | undefined;
    taskInitiatedBy?: number | undefined;
    reasonforEscalation?: string | undefined;
}

export class Int32BaseResponse implements IInt32BaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: number;

    constructor(data?: IInt32BaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): Int32BaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int32BaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response;
        return data;
    }
}

export interface IInt32BaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: number;
}

export class IsertFirmStatusObj implements IIsertFirmStatusObj {
    firmId?: number | undefined;
    firmApplID?: number | undefined;
    firmApplStatusTypeID?: number | undefined;
    loginuserId?: number | undefined;
    firmApplStatusDate?: Date | undefined;
    firmApplStatusID?: number | undefined;

    constructor(data?: IIsertFirmStatusObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmId = _data["firmId"];
            this.firmApplID = _data["firmApplID"];
            this.firmApplStatusTypeID = _data["firmApplStatusTypeID"];
            this.loginuserId = _data["loginuserId"];
            this.firmApplStatusDate = _data["firmApplStatusDate"] ? new Date(_data["firmApplStatusDate"].toString()) : <any>undefined;
            this.firmApplStatusID = _data["firmApplStatusID"];
        }
    }

    static fromJS(data: any): IsertFirmStatusObj {
        data = typeof data === 'object' ? data : {};
        let result = new IsertFirmStatusObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmId"] = this.firmId;
        data["firmApplID"] = this.firmApplID;
        data["firmApplStatusTypeID"] = this.firmApplStatusTypeID;
        data["loginuserId"] = this.loginuserId;
        data["firmApplStatusDate"] = this.firmApplStatusDate ? this.firmApplStatusDate.toISOString() : <any>undefined;
        data["firmApplStatusID"] = this.firmApplStatusID;
        return data;
    }
}

export interface IIsertFirmStatusObj {
    firmId?: number | undefined;
    firmApplID?: number | undefined;
    firmApplStatusTypeID?: number | undefined;
    loginuserId?: number | undefined;
    firmApplStatusDate?: Date | undefined;
    firmApplStatusID?: number | undefined;
}

export class NoticCriteriaObj implements INoticCriteriaObj {
    noticeResponseEvaluationCriteriaID?: number | undefined;
    noticeID?: number | undefined;
    noticeQuestionnaireID?: number | undefined;
    noticeQuestionnaireItemID?: number | undefined;
    evaluationReasonTypeID?: number | undefined;
    responseOperatorTypeID?: number | undefined;
    response?: string | undefined;
    responseTo?: string | undefined;
    listValueID?: number | undefined;
    createdBy?: number | undefined;

    constructor(data?: INoticCriteriaObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeResponseEvaluationCriteriaID = _data["noticeResponseEvaluationCriteriaID"];
            this.noticeID = _data["noticeID"];
            this.noticeQuestionnaireID = _data["noticeQuestionnaireID"];
            this.noticeQuestionnaireItemID = _data["noticeQuestionnaireItemID"];
            this.evaluationReasonTypeID = _data["evaluationReasonTypeID"];
            this.responseOperatorTypeID = _data["responseOperatorTypeID"];
            this.response = _data["response"];
            this.responseTo = _data["responseTo"];
            this.listValueID = _data["listValueID"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): NoticCriteriaObj {
        data = typeof data === 'object' ? data : {};
        let result = new NoticCriteriaObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeResponseEvaluationCriteriaID"] = this.noticeResponseEvaluationCriteriaID;
        data["noticeID"] = this.noticeID;
        data["noticeQuestionnaireID"] = this.noticeQuestionnaireID;
        data["noticeQuestionnaireItemID"] = this.noticeQuestionnaireItemID;
        data["evaluationReasonTypeID"] = this.evaluationReasonTypeID;
        data["responseOperatorTypeID"] = this.responseOperatorTypeID;
        data["response"] = this.response;
        data["responseTo"] = this.responseTo;
        data["listValueID"] = this.listValueID;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface INoticCriteriaObj {
    noticeResponseEvaluationCriteriaID?: number | undefined;
    noticeID?: number | undefined;
    noticeQuestionnaireID?: number | undefined;
    noticeQuestionnaireItemID?: number | undefined;
    evaluationReasonTypeID?: number | undefined;
    responseOperatorTypeID?: number | undefined;
    response?: string | undefined;
    responseTo?: string | undefined;
    listValueID?: number | undefined;
    createdBy?: number | undefined;
}

export class NoticeQuestionaireItemsObj implements INoticeQuestionaireItemsObj {
    noticeQuestionnaireItemID?: number | undefined;
    noticeID?: number | undefined;
    noticeQuestionnaireID?: number | undefined;
    noticeQuestionNumber?: string | undefined;
    noticeQuestion?: string | undefined;
    responseTypeID?: number | undefined;
    listNameID?: number | undefined;
    explanationRequired?: number | undefined;
    questionDisplayOrder?: number | undefined;
    createdBy?: number | undefined;
    responseMandatory?: boolean | undefined;

    constructor(data?: INoticeQuestionaireItemsObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeQuestionnaireItemID = _data["noticeQuestionnaireItemID"];
            this.noticeID = _data["noticeID"];
            this.noticeQuestionnaireID = _data["noticeQuestionnaireID"];
            this.noticeQuestionNumber = _data["noticeQuestionNumber"];
            this.noticeQuestion = _data["noticeQuestion"];
            this.responseTypeID = _data["responseTypeID"];
            this.listNameID = _data["listNameID"];
            this.explanationRequired = _data["explanationRequired"];
            this.questionDisplayOrder = _data["questionDisplayOrder"];
            this.createdBy = _data["createdBy"];
            this.responseMandatory = _data["responseMandatory"];
        }
    }

    static fromJS(data: any): NoticeQuestionaireItemsObj {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeQuestionaireItemsObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeQuestionnaireItemID"] = this.noticeQuestionnaireItemID;
        data["noticeID"] = this.noticeID;
        data["noticeQuestionnaireID"] = this.noticeQuestionnaireID;
        data["noticeQuestionNumber"] = this.noticeQuestionNumber;
        data["noticeQuestion"] = this.noticeQuestion;
        data["responseTypeID"] = this.responseTypeID;
        data["listNameID"] = this.listNameID;
        data["explanationRequired"] = this.explanationRequired;
        data["questionDisplayOrder"] = this.questionDisplayOrder;
        data["createdBy"] = this.createdBy;
        data["responseMandatory"] = this.responseMandatory;
        return data;
    }
}

export interface INoticeQuestionaireItemsObj {
    noticeQuestionnaireItemID?: number | undefined;
    noticeID?: number | undefined;
    noticeQuestionnaireID?: number | undefined;
    noticeQuestionNumber?: string | undefined;
    noticeQuestion?: string | undefined;
    responseTypeID?: number | undefined;
    listNameID?: number | undefined;
    explanationRequired?: number | undefined;
    questionDisplayOrder?: number | undefined;
    createdBy?: number | undefined;
    responseMandatory?: boolean | undefined;
}

export class NoticeQuestionaireObj implements INoticeQuestionaireObj {
    noticeQuestionnaireID?: number | undefined;
    noticeID?: number | undefined;
    workingDaysForResponse?: number | undefined;
    respondentTypeID?: number | undefined;
    respondentsControlledFunctionTypeIDs?: string | undefined;
    respondentsDNFBPFunctionTypeIDs?: string | undefined;
    subjectToLateFee?: boolean | undefined;
    sendResponseToSUPSupervisor?: number | undefined;
    sendResponseToAMLSupervisor?: number | undefined;
    sendResponseToSUPDirector?: number | undefined;
    sendResponseToAMLDirector?: number | undefined;
    sendResponseToMD?: number | undefined;
    createdBy?: number | undefined;
    opType?: string | undefined;

    constructor(data?: INoticeQuestionaireObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeQuestionnaireID = _data["noticeQuestionnaireID"];
            this.noticeID = _data["noticeID"];
            this.workingDaysForResponse = _data["workingDaysForResponse"];
            this.respondentTypeID = _data["respondentTypeID"];
            this.respondentsControlledFunctionTypeIDs = _data["respondentsControlledFunctionTypeIDs"];
            this.respondentsDNFBPFunctionTypeIDs = _data["respondentsDNFBPFunctionTypeIDs"];
            this.subjectToLateFee = _data["subjectToLateFee"];
            this.sendResponseToSUPSupervisor = _data["sendResponseToSUPSupervisor"];
            this.sendResponseToAMLSupervisor = _data["sendResponseToAMLSupervisor"];
            this.sendResponseToSUPDirector = _data["sendResponseToSUPDirector"];
            this.sendResponseToAMLDirector = _data["sendResponseToAMLDirector"];
            this.sendResponseToMD = _data["sendResponseToMD"];
            this.createdBy = _data["createdBy"];
            this.opType = _data["opType"];
        }
    }

    static fromJS(data: any): NoticeQuestionaireObj {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeQuestionaireObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeQuestionnaireID"] = this.noticeQuestionnaireID;
        data["noticeID"] = this.noticeID;
        data["workingDaysForResponse"] = this.workingDaysForResponse;
        data["respondentTypeID"] = this.respondentTypeID;
        data["respondentsControlledFunctionTypeIDs"] = this.respondentsControlledFunctionTypeIDs;
        data["respondentsDNFBPFunctionTypeIDs"] = this.respondentsDNFBPFunctionTypeIDs;
        data["subjectToLateFee"] = this.subjectToLateFee;
        data["sendResponseToSUPSupervisor"] = this.sendResponseToSUPSupervisor;
        data["sendResponseToAMLSupervisor"] = this.sendResponseToAMLSupervisor;
        data["sendResponseToSUPDirector"] = this.sendResponseToSUPDirector;
        data["sendResponseToAMLDirector"] = this.sendResponseToAMLDirector;
        data["sendResponseToMD"] = this.sendResponseToMD;
        data["createdBy"] = this.createdBy;
        data["opType"] = this.opType;
        return data;
    }
}

export interface INoticeQuestionaireObj {
    noticeQuestionnaireID?: number | undefined;
    noticeID?: number | undefined;
    workingDaysForResponse?: number | undefined;
    respondentTypeID?: number | undefined;
    respondentsControlledFunctionTypeIDs?: string | undefined;
    respondentsDNFBPFunctionTypeIDs?: string | undefined;
    subjectToLateFee?: boolean | undefined;
    sendResponseToSUPSupervisor?: number | undefined;
    sendResponseToAMLSupervisor?: number | undefined;
    sendResponseToSUPDirector?: number | undefined;
    sendResponseToAMLDirector?: number | undefined;
    sendResponseToMD?: number | undefined;
    createdBy?: number | undefined;
    opType?: string | undefined;
}

export class NoticeTemplateQuestionaireItemsObj implements INoticeTemplateQuestionaireItemsObj {
    noticeTemplateQuestionnaireItemID?: number | undefined;
    noticeTemplateID?: number | undefined;
    noticeTemplateQuestionnaireID?: number | undefined;
    noticeQuestionNumber?: string | undefined;
    noticeQuestion?: string | undefined;
    responseTypeID?: number | undefined;
    listNameID?: number | undefined;
    explanationRequired?: number | undefined;
    questionDisplayOrder?: number | undefined;
    createdBy?: number | undefined;
    responseMandatory?: boolean | undefined;

    constructor(data?: INoticeTemplateQuestionaireItemsObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeTemplateQuestionnaireItemID = _data["noticeTemplateQuestionnaireItemID"];
            this.noticeTemplateID = _data["noticeTemplateID"];
            this.noticeTemplateQuestionnaireID = _data["noticeTemplateQuestionnaireID"];
            this.noticeQuestionNumber = _data["noticeQuestionNumber"];
            this.noticeQuestion = _data["noticeQuestion"];
            this.responseTypeID = _data["responseTypeID"];
            this.listNameID = _data["listNameID"];
            this.explanationRequired = _data["explanationRequired"];
            this.questionDisplayOrder = _data["questionDisplayOrder"];
            this.createdBy = _data["createdBy"];
            this.responseMandatory = _data["responseMandatory"];
        }
    }

    static fromJS(data: any): NoticeTemplateQuestionaireItemsObj {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeTemplateQuestionaireItemsObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeTemplateQuestionnaireItemID"] = this.noticeTemplateQuestionnaireItemID;
        data["noticeTemplateID"] = this.noticeTemplateID;
        data["noticeTemplateQuestionnaireID"] = this.noticeTemplateQuestionnaireID;
        data["noticeQuestionNumber"] = this.noticeQuestionNumber;
        data["noticeQuestion"] = this.noticeQuestion;
        data["responseTypeID"] = this.responseTypeID;
        data["listNameID"] = this.listNameID;
        data["explanationRequired"] = this.explanationRequired;
        data["questionDisplayOrder"] = this.questionDisplayOrder;
        data["createdBy"] = this.createdBy;
        data["responseMandatory"] = this.responseMandatory;
        return data;
    }
}

export interface INoticeTemplateQuestionaireItemsObj {
    noticeTemplateQuestionnaireItemID?: number | undefined;
    noticeTemplateID?: number | undefined;
    noticeTemplateQuestionnaireID?: number | undefined;
    noticeQuestionNumber?: string | undefined;
    noticeQuestion?: string | undefined;
    responseTypeID?: number | undefined;
    listNameID?: number | undefined;
    explanationRequired?: number | undefined;
    questionDisplayOrder?: number | undefined;
    createdBy?: number | undefined;
    responseMandatory?: boolean | undefined;
}

export class NoticeTemplateQuestionaireObj implements INoticeTemplateQuestionaireObj {
    noticeTemplateQuestionnaireID?: number | undefined;
    noticeTemplateID?: number | undefined;
    workingDaysForResponse?: number | undefined;
    respondentTypeID?: number | undefined;
    respondentsControlledFunctionTypeIDs?: string | undefined;
    respondentsDNFBPFunctionTypeIDs?: string | undefined;
    subjectToLateFee?: boolean | undefined;
    sendResponseToSUPSupervisor?: number | undefined;
    sendResponseToAMLSupervisor?: number | undefined;
    sendResponseToSUPDirector?: number | undefined;
    sendResponseToAMLDirector?: number | undefined;
    sendResponseToMD?: number | undefined;
    createdBy?: number | undefined;
    opType?: string | undefined;

    constructor(data?: INoticeTemplateQuestionaireObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeTemplateQuestionnaireID = _data["noticeTemplateQuestionnaireID"];
            this.noticeTemplateID = _data["noticeTemplateID"];
            this.workingDaysForResponse = _data["workingDaysForResponse"];
            this.respondentTypeID = _data["respondentTypeID"];
            this.respondentsControlledFunctionTypeIDs = _data["respondentsControlledFunctionTypeIDs"];
            this.respondentsDNFBPFunctionTypeIDs = _data["respondentsDNFBPFunctionTypeIDs"];
            this.subjectToLateFee = _data["subjectToLateFee"];
            this.sendResponseToSUPSupervisor = _data["sendResponseToSUPSupervisor"];
            this.sendResponseToAMLSupervisor = _data["sendResponseToAMLSupervisor"];
            this.sendResponseToSUPDirector = _data["sendResponseToSUPDirector"];
            this.sendResponseToAMLDirector = _data["sendResponseToAMLDirector"];
            this.sendResponseToMD = _data["sendResponseToMD"];
            this.createdBy = _data["createdBy"];
            this.opType = _data["opType"];
        }
    }

    static fromJS(data: any): NoticeTemplateQuestionaireObj {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeTemplateQuestionaireObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeTemplateQuestionnaireID"] = this.noticeTemplateQuestionnaireID;
        data["noticeTemplateID"] = this.noticeTemplateID;
        data["workingDaysForResponse"] = this.workingDaysForResponse;
        data["respondentTypeID"] = this.respondentTypeID;
        data["respondentsControlledFunctionTypeIDs"] = this.respondentsControlledFunctionTypeIDs;
        data["respondentsDNFBPFunctionTypeIDs"] = this.respondentsDNFBPFunctionTypeIDs;
        data["subjectToLateFee"] = this.subjectToLateFee;
        data["sendResponseToSUPSupervisor"] = this.sendResponseToSUPSupervisor;
        data["sendResponseToAMLSupervisor"] = this.sendResponseToAMLSupervisor;
        data["sendResponseToSUPDirector"] = this.sendResponseToSUPDirector;
        data["sendResponseToAMLDirector"] = this.sendResponseToAMLDirector;
        data["sendResponseToMD"] = this.sendResponseToMD;
        data["createdBy"] = this.createdBy;
        data["opType"] = this.opType;
        return data;
    }
}

export interface INoticeTemplateQuestionaireObj {
    noticeTemplateQuestionnaireID?: number | undefined;
    noticeTemplateID?: number | undefined;
    workingDaysForResponse?: number | undefined;
    respondentTypeID?: number | undefined;
    respondentsControlledFunctionTypeIDs?: string | undefined;
    respondentsDNFBPFunctionTypeIDs?: string | undefined;
    subjectToLateFee?: boolean | undefined;
    sendResponseToSUPSupervisor?: number | undefined;
    sendResponseToAMLSupervisor?: number | undefined;
    sendResponseToSUPDirector?: number | undefined;
    sendResponseToAMLDirector?: number | undefined;
    sendResponseToMD?: number | undefined;
    createdBy?: number | undefined;
    opType?: string | undefined;
}

export class NoticeTemplateResponseCriteriaObj implements INoticeTemplateResponseCriteriaObj {
    noticeTemplateResponseEvaluationCriteriaID?: number | undefined;
    noticeTemplateID?: number | undefined;
    noticeTemplateQuestionnaireID?: number | undefined;
    noticeTemplateQuestionnaireItemID?: number | undefined;
    evaluationReasonTypeID?: number | undefined;
    responseOperatorTypeID?: number | undefined;
    response?: string | undefined;
    responseTo?: string | undefined;
    listValueID?: number | undefined;
    createdBy?: number | undefined;

    constructor(data?: INoticeTemplateResponseCriteriaObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeTemplateResponseEvaluationCriteriaID = _data["noticeTemplateResponseEvaluationCriteriaID"];
            this.noticeTemplateID = _data["noticeTemplateID"];
            this.noticeTemplateQuestionnaireID = _data["noticeTemplateQuestionnaireID"];
            this.noticeTemplateQuestionnaireItemID = _data["noticeTemplateQuestionnaireItemID"];
            this.evaluationReasonTypeID = _data["evaluationReasonTypeID"];
            this.responseOperatorTypeID = _data["responseOperatorTypeID"];
            this.response = _data["response"];
            this.responseTo = _data["responseTo"];
            this.listValueID = _data["listValueID"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): NoticeTemplateResponseCriteriaObj {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeTemplateResponseCriteriaObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeTemplateResponseEvaluationCriteriaID"] = this.noticeTemplateResponseEvaluationCriteriaID;
        data["noticeTemplateID"] = this.noticeTemplateID;
        data["noticeTemplateQuestionnaireID"] = this.noticeTemplateQuestionnaireID;
        data["noticeTemplateQuestionnaireItemID"] = this.noticeTemplateQuestionnaireItemID;
        data["evaluationReasonTypeID"] = this.evaluationReasonTypeID;
        data["responseOperatorTypeID"] = this.responseOperatorTypeID;
        data["response"] = this.response;
        data["responseTo"] = this.responseTo;
        data["listValueID"] = this.listValueID;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface INoticeTemplateResponseCriteriaObj {
    noticeTemplateResponseEvaluationCriteriaID?: number | undefined;
    noticeTemplateID?: number | undefined;
    noticeTemplateQuestionnaireID?: number | undefined;
    noticeTemplateQuestionnaireItemID?: number | undefined;
    evaluationReasonTypeID?: number | undefined;
    responseOperatorTypeID?: number | undefined;
    response?: string | undefined;
    responseTo?: string | undefined;
    listValueID?: number | undefined;
    createdBy?: number | undefined;
}

export class NoticeTemplatesObj implements INoticeTemplatesObj {
    noticeTypeID?: number | undefined;
    noticeTemplateID?: number | undefined;
    noticeTemplateName?: string | undefined;
    noticeIssuerID?: number | undefined;
    otherNoticeIssuer?: string | undefined;
    noticeIssuedDate?: Date | undefined;
    publishOnESS?: boolean | undefined;
    publishOnWebsite?: boolean | undefined;
    recipientCriteriaCSVFirmTypeIDs?: string | undefined;
    recipientCriteriaCSVfirmIds?: string | undefined;
    recipientCriteriaCSVControlledFunctionTypeIDs?: string | undefined;
    recipientCriteriaCSVDNFBPFunctionTypeIDs?: string | undefined;
    sendNoticeToSUPSupervisor?: boolean | undefined;
    sendNoticeToAMLSupervisor?: boolean | undefined;
    emailNotificationContent?: string | undefined;
    createdBy?: number | undefined;
    opType?: string | undefined;
    noticeOriginator?: string | undefined;
    editableWhenUsed?: boolean | undefined;
    dateValidFrom?: Date | undefined;
    dateValidTo?: Date | undefined;
    recipientCriteriaCSVContactTypeIDs?: string | undefined;

    constructor(data?: INoticeTemplatesObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeTypeID = _data["noticeTypeID"];
            this.noticeTemplateID = _data["noticeTemplateID"];
            this.noticeTemplateName = _data["noticeTemplateName"];
            this.noticeIssuerID = _data["noticeIssuerID"];
            this.otherNoticeIssuer = _data["otherNoticeIssuer"];
            this.noticeIssuedDate = _data["noticeIssuedDate"] ? new Date(_data["noticeIssuedDate"].toString()) : <any>undefined;
            this.publishOnESS = _data["publishOnESS"];
            this.publishOnWebsite = _data["publishOnWebsite"];
            this.recipientCriteriaCSVFirmTypeIDs = _data["recipientCriteriaCSVFirmTypeIDs"];
            this.recipientCriteriaCSVfirmIds = _data["recipientCriteriaCSVfirmIds"];
            this.recipientCriteriaCSVControlledFunctionTypeIDs = _data["recipientCriteriaCSVControlledFunctionTypeIDs"];
            this.recipientCriteriaCSVDNFBPFunctionTypeIDs = _data["recipientCriteriaCSVDNFBPFunctionTypeIDs"];
            this.sendNoticeToSUPSupervisor = _data["sendNoticeToSUPSupervisor"];
            this.sendNoticeToAMLSupervisor = _data["sendNoticeToAMLSupervisor"];
            this.emailNotificationContent = _data["emailNotificationContent"];
            this.createdBy = _data["createdBy"];
            this.opType = _data["opType"];
            this.noticeOriginator = _data["noticeOriginator"];
            this.editableWhenUsed = _data["editableWhenUsed"];
            this.dateValidFrom = _data["dateValidFrom"] ? new Date(_data["dateValidFrom"].toString()) : <any>undefined;
            this.dateValidTo = _data["dateValidTo"] ? new Date(_data["dateValidTo"].toString()) : <any>undefined;
            this.recipientCriteriaCSVContactTypeIDs = _data["recipientCriteriaCSVContactTypeIDs"];
        }
    }

    static fromJS(data: any): NoticeTemplatesObj {
        data = typeof data === 'object' ? data : {};
        let result = new NoticeTemplatesObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeTypeID"] = this.noticeTypeID;
        data["noticeTemplateID"] = this.noticeTemplateID;
        data["noticeTemplateName"] = this.noticeTemplateName;
        data["noticeIssuerID"] = this.noticeIssuerID;
        data["otherNoticeIssuer"] = this.otherNoticeIssuer;
        data["noticeIssuedDate"] = this.noticeIssuedDate ? this.noticeIssuedDate.toISOString() : <any>undefined;
        data["publishOnESS"] = this.publishOnESS;
        data["publishOnWebsite"] = this.publishOnWebsite;
        data["recipientCriteriaCSVFirmTypeIDs"] = this.recipientCriteriaCSVFirmTypeIDs;
        data["recipientCriteriaCSVfirmIds"] = this.recipientCriteriaCSVfirmIds;
        data["recipientCriteriaCSVControlledFunctionTypeIDs"] = this.recipientCriteriaCSVControlledFunctionTypeIDs;
        data["recipientCriteriaCSVDNFBPFunctionTypeIDs"] = this.recipientCriteriaCSVDNFBPFunctionTypeIDs;
        data["sendNoticeToSUPSupervisor"] = this.sendNoticeToSUPSupervisor;
        data["sendNoticeToAMLSupervisor"] = this.sendNoticeToAMLSupervisor;
        data["emailNotificationContent"] = this.emailNotificationContent;
        data["createdBy"] = this.createdBy;
        data["opType"] = this.opType;
        data["noticeOriginator"] = this.noticeOriginator;
        data["editableWhenUsed"] = this.editableWhenUsed;
        data["dateValidFrom"] = this.dateValidFrom ? this.dateValidFrom.toISOString() : <any>undefined;
        data["dateValidTo"] = this.dateValidTo ? this.dateValidTo.toISOString() : <any>undefined;
        data["recipientCriteriaCSVContactTypeIDs"] = this.recipientCriteriaCSVContactTypeIDs;
        return data;
    }
}

export interface INoticeTemplatesObj {
    noticeTypeID?: number | undefined;
    noticeTemplateID?: number | undefined;
    noticeTemplateName?: string | undefined;
    noticeIssuerID?: number | undefined;
    otherNoticeIssuer?: string | undefined;
    noticeIssuedDate?: Date | undefined;
    publishOnESS?: boolean | undefined;
    publishOnWebsite?: boolean | undefined;
    recipientCriteriaCSVFirmTypeIDs?: string | undefined;
    recipientCriteriaCSVfirmIds?: string | undefined;
    recipientCriteriaCSVControlledFunctionTypeIDs?: string | undefined;
    recipientCriteriaCSVDNFBPFunctionTypeIDs?: string | undefined;
    sendNoticeToSUPSupervisor?: boolean | undefined;
    sendNoticeToAMLSupervisor?: boolean | undefined;
    emailNotificationContent?: string | undefined;
    createdBy?: number | undefined;
    opType?: string | undefined;
    noticeOriginator?: string | undefined;
    editableWhenUsed?: boolean | undefined;
    dateValidFrom?: Date | undefined;
    dateValidTo?: Date | undefined;
    recipientCriteriaCSVContactTypeIDs?: string | undefined;
}

export class ObjectReviewObj implements IObjectReviewObj {
    objectWFTaskStatusID?: number | undefined;
    objectWFStatusID?: number | undefined;
    objectTaskTypeID?: number | undefined;
    wfTaskAssignedToUser?: number | undefined;
    wfTaskAssignedToRole?: number | undefined;
    emailTo?: string | undefined;
    emailCC?: string | undefined;
    completionAssignToUser?: number | undefined;
    completionAssignToRole?: number | undefined;
    completionEmailTO?: string | undefined;
    completionEmailCC?: string | undefined;
    objectWFTaskStart?: boolean | undefined;
    logInBy?: number | undefined;

    constructor(data?: IObjectReviewObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectWFTaskStatusID = _data["objectWFTaskStatusID"];
            this.objectWFStatusID = _data["objectWFStatusID"];
            this.objectTaskTypeID = _data["objectTaskTypeID"];
            this.wfTaskAssignedToUser = _data["wfTaskAssignedToUser"];
            this.wfTaskAssignedToRole = _data["wfTaskAssignedToRole"];
            this.emailTo = _data["emailTo"];
            this.emailCC = _data["emailCC"];
            this.completionAssignToUser = _data["completionAssignToUser"];
            this.completionAssignToRole = _data["completionAssignToRole"];
            this.completionEmailTO = _data["completionEmailTO"];
            this.completionEmailCC = _data["completionEmailCC"];
            this.objectWFTaskStart = _data["objectWFTaskStart"];
            this.logInBy = _data["logInBy"];
        }
    }

    static fromJS(data: any): ObjectReviewObj {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectReviewObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectWFTaskStatusID"] = this.objectWFTaskStatusID;
        data["objectWFStatusID"] = this.objectWFStatusID;
        data["objectTaskTypeID"] = this.objectTaskTypeID;
        data["wfTaskAssignedToUser"] = this.wfTaskAssignedToUser;
        data["wfTaskAssignedToRole"] = this.wfTaskAssignedToRole;
        data["emailTo"] = this.emailTo;
        data["emailCC"] = this.emailCC;
        data["completionAssignToUser"] = this.completionAssignToUser;
        data["completionAssignToRole"] = this.completionAssignToRole;
        data["completionEmailTO"] = this.completionEmailTO;
        data["completionEmailCC"] = this.completionEmailCC;
        data["objectWFTaskStart"] = this.objectWFTaskStart;
        data["logInBy"] = this.logInBy;
        return data;
    }
}

export interface IObjectReviewObj {
    objectWFTaskStatusID?: number | undefined;
    objectWFStatusID?: number | undefined;
    objectTaskTypeID?: number | undefined;
    wfTaskAssignedToUser?: number | undefined;
    wfTaskAssignedToRole?: number | undefined;
    emailTo?: string | undefined;
    emailCC?: string | undefined;
    completionAssignToUser?: number | undefined;
    completionAssignToRole?: number | undefined;
    completionEmailTO?: string | undefined;
    completionEmailCC?: string | undefined;
    objectWFTaskStart?: boolean | undefined;
    logInBy?: number | undefined;
}

export class ObjectWFCommentsObj implements IObjectWFCommentsObj {
    objectID?: number | undefined;
    objectWFTaskStatusID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    objectWFComments?: string | undefined;
    commentsBy?: number | undefined;
    objectWFCommentID?: number | undefined;

    constructor(data?: IObjectWFCommentsObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.objectWFTaskStatusID = _data["objectWFTaskStatusID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.objectInstanceRevNum = _data["objectInstanceRevNum"];
            this.objectWFComments = _data["objectWFComments"];
            this.commentsBy = _data["commentsBy"];
            this.objectWFCommentID = _data["objectWFCommentID"];
        }
    }

    static fromJS(data: any): ObjectWFCommentsObj {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectWFCommentsObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["objectWFTaskStatusID"] = this.objectWFTaskStatusID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["objectInstanceRevNum"] = this.objectInstanceRevNum;
        data["objectWFComments"] = this.objectWFComments;
        data["commentsBy"] = this.commentsBy;
        data["objectWFCommentID"] = this.objectWFCommentID;
        return data;
    }
}

export interface IObjectWFCommentsObj {
    objectID?: number | undefined;
    objectWFTaskStatusID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    objectWFComments?: string | undefined;
    commentsBy?: number | undefined;
    objectWFCommentID?: number | undefined;
}

export class ObjectWFDetailsObj implements IObjectWFDetailsObj {
    objectId?: number | undefined;
    objectInstanceId?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    objectWFStatusId?: number | undefined;

    constructor(data?: IObjectWFDetailsObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectId = _data["objectId"];
            this.objectInstanceId = _data["objectInstanceId"];
            this.objectInstanceRevNum = _data["objectInstanceRevNum"];
            this.objectWFStatusId = _data["objectWFStatusId"];
        }
    }

    static fromJS(data: any): ObjectWFDetailsObj {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectWFDetailsObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        data["objectInstanceId"] = this.objectInstanceId;
        data["objectInstanceRevNum"] = this.objectInstanceRevNum;
        data["objectWFStatusId"] = this.objectWFStatusId;
        return data;
    }
}

export interface IObjectWFDetailsObj {
    objectId?: number | undefined;
    objectInstanceId?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    objectWFStatusId?: number | undefined;
}

export class ObjectWFStarObj implements IObjectWFStarObj {
    objWfStatusId?: number | undefined;
    lastModifiedBy?: number | undefined;
    objectId?: number | undefined;

    constructor(data?: IObjectWFStarObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objWfStatusId = _data["objWfStatusId"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.objectId = _data["objectId"];
        }
    }

    static fromJS(data: any): ObjectWFStarObj {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectWFStarObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objWfStatusId"] = this.objWfStatusId;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["objectId"] = this.objectId;
        return data;
    }
}

export interface IObjectWFStarObj {
    objWfStatusId?: number | undefined;
    lastModifiedBy?: number | undefined;
    objectId?: number | undefined;
}

export class PersonalReminderObject implements IPersonalReminderObject {
    userId?: number | undefined;
    summary?: string | undefined;
    firmId?: number | undefined;
    notes?: string | undefined;
    dueDate?: Date | undefined;
    status?: number | undefined;
    objectActItmID?: number | undefined;
    outparam?: number | undefined;

    constructor(data?: IPersonalReminderObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.summary = _data["summary"];
            this.firmId = _data["firmId"];
            this.notes = _data["notes"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.objectActItmID = _data["objectActItmID"];
            this.outparam = _data["outparam"];
        }
    }

    static fromJS(data: any): PersonalReminderObject {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalReminderObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["summary"] = this.summary;
        data["firmId"] = this.firmId;
        data["notes"] = this.notes;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["objectActItmID"] = this.objectActItmID;
        data["outparam"] = this.outparam;
        return data;
    }
}

export interface IPersonalReminderObject {
    userId?: number | undefined;
    summary?: string | undefined;
    firmId?: number | undefined;
    notes?: string | undefined;
    dueDate?: Date | undefined;
    status?: number | undefined;
    objectActItmID?: number | undefined;
    outparam?: number | undefined;
}

export class ProductActivityDto implements IProductActivityDto {
    productTypeID?: string | undefined;
    appliedDate?: Date | undefined;
    withDrawnDate?: Date | undefined;
    effectiveDate?: Date | undefined;
    firmScopeTypeID?: number | undefined;

    constructor(data?: IProductActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productTypeID = _data["productTypeID"];
            this.appliedDate = _data["appliedDate"] ? new Date(_data["appliedDate"].toString()) : <any>undefined;
            this.withDrawnDate = _data["withDrawnDate"] ? new Date(_data["withDrawnDate"].toString()) : <any>undefined;
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.firmScopeTypeID = _data["firmScopeTypeID"];
        }
    }

    static fromJS(data: any): ProductActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productTypeID"] = this.productTypeID;
        data["appliedDate"] = this.appliedDate ? this.appliedDate.toISOString() : <any>undefined;
        data["withDrawnDate"] = this.withDrawnDate ? this.withDrawnDate.toISOString() : <any>undefined;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["firmScopeTypeID"] = this.firmScopeTypeID;
        return data;
    }
}

export interface IProductActivityDto {
    productTypeID?: string | undefined;
    appliedDate?: Date | undefined;
    withDrawnDate?: Date | undefined;
    effectiveDate?: Date | undefined;
    firmScopeTypeID?: number | undefined;
}

export class PrudentialCategoryDto implements IPrudentialCategoryDto {
    firmPrudentialCategoryID?: number | undefined;
    firmId?: number | undefined;
    prudentialCategoryTypeID?: number | undefined;
    firmScopeID?: number | undefined;
    scopeRevNum?: number | undefined;
    lastModifiedByID?: number | undefined;
    effectiveDate?: Date | undefined;
    expirationDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
    authorisationCategoryTypeID?: number | undefined;

    constructor(data?: IPrudentialCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmPrudentialCategoryID = _data["firmPrudentialCategoryID"];
            this.firmId = _data["firmId"];
            this.prudentialCategoryTypeID = _data["prudentialCategoryTypeID"];
            this.firmScopeID = _data["firmScopeID"];
            this.scopeRevNum = _data["scopeRevNum"];
            this.lastModifiedByID = _data["lastModifiedByID"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.authorisationCategoryTypeID = _data["authorisationCategoryTypeID"];
        }
    }

    static fromJS(data: any): PrudentialCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrudentialCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmPrudentialCategoryID"] = this.firmPrudentialCategoryID;
        data["firmId"] = this.firmId;
        data["prudentialCategoryTypeID"] = this.prudentialCategoryTypeID;
        data["firmScopeID"] = this.firmScopeID;
        data["scopeRevNum"] = this.scopeRevNum;
        data["lastModifiedByID"] = this.lastModifiedByID;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["authorisationCategoryTypeID"] = this.authorisationCategoryTypeID;
        return data;
    }
}

export interface IPrudentialCategoryDto {
    firmPrudentialCategoryID?: number | undefined;
    firmId?: number | undefined;
    prudentialCategoryTypeID?: number | undefined;
    firmScopeID?: number | undefined;
    scopeRevNum?: number | undefined;
    lastModifiedByID?: number | undefined;
    effectiveDate?: Date | undefined;
    expirationDate?: Date | undefined;
    lastModifiedDate?: Date | undefined;
    authorisationCategoryTypeID?: number | undefined;
}

export class PublishReportingObj implements IPublishReportingObj {
    reportSchID?: number | undefined;
    publishedBy?: number | undefined;
    csvRptSchItemID?: string | undefined;

    constructor(data?: IPublishReportingObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportSchID = _data["reportSchID"];
            this.publishedBy = _data["publishedBy"];
            this.csvRptSchItemID = _data["csvRptSchItemID"];
        }
    }

    static fromJS(data: any): PublishReportingObj {
        data = typeof data === 'object' ? data : {};
        let result = new PublishReportingObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportSchID"] = this.reportSchID;
        data["publishedBy"] = this.publishedBy;
        data["csvRptSchItemID"] = this.csvRptSchItemID;
        return data;
    }
}

export interface IPublishReportingObj {
    reportSchID?: number | undefined;
    publishedBy?: number | undefined;
    csvRptSchItemID?: string | undefined;
}

export class RMPStatusObj implements IRMPStatusObj {
    wfStatusID?: number | undefined;
    rmpInitialSignOffStatusID?: number | undefined;
    firmRMPID?: number | undefined;

    constructor(data?: IRMPStatusObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wfStatusID = _data["wfStatusID"];
            this.rmpInitialSignOffStatusID = _data["rmpInitialSignOffStatusID"];
            this.firmRMPID = _data["firmRMPID"];
        }
    }

    static fromJS(data: any): RMPStatusObj {
        data = typeof data === 'object' ? data : {};
        let result = new RMPStatusObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wfStatusID"] = this.wfStatusID;
        data["rmpInitialSignOffStatusID"] = this.rmpInitialSignOffStatusID;
        data["firmRMPID"] = this.firmRMPID;
        return data;
    }
}

export interface IRMPStatusObj {
    wfStatusID?: number | undefined;
    rmpInitialSignOffStatusID?: number | undefined;
    firmRMPID?: number | undefined;
}

export class RecipientObj implements IRecipientObj {
    docRecipientID?: number | undefined;
    docID?: number | undefined;
    rAAffiliateID?: number | undefined;
    appRoleID?: number | undefined;
    recipientID?: number | undefined;
    docSendDate?: Date | undefined;
    userId?: number | undefined;
    createdDate?: Date | undefined;

    constructor(data?: IRecipientObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docRecipientID = _data["docRecipientID"];
            this.docID = _data["docID"];
            this.rAAffiliateID = _data["rAAffiliateID"];
            this.appRoleID = _data["appRoleID"];
            this.recipientID = _data["recipientID"];
            this.docSendDate = _data["docSendDate"] ? new Date(_data["docSendDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecipientObj {
        data = typeof data === 'object' ? data : {};
        let result = new RecipientObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docRecipientID"] = this.docRecipientID;
        data["docID"] = this.docID;
        data["rAAffiliateID"] = this.rAAffiliateID;
        data["appRoleID"] = this.appRoleID;
        data["recipientID"] = this.recipientID;
        data["docSendDate"] = this.docSendDate ? this.docSendDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRecipientObj {
    docRecipientID?: number | undefined;
    docID?: number | undefined;
    rAAffiliateID?: number | undefined;
    appRoleID?: number | undefined;
    recipientID?: number | undefined;
    docSendDate?: Date | undefined;
    userId?: number | undefined;
    createdDate?: Date | undefined;
}

export class ReminderNoteObject implements IReminderNoteObject {
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    notes?: string | undefined;
    createdBy?: number | undefined;

    constructor(data?: IReminderNoteObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectID = _data["objectID"];
            this.objectInstanceID = _data["objectInstanceID"];
            this.objectInstanceRevNum = _data["objectInstanceRevNum"];
            this.notes = _data["notes"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): ReminderNoteObject {
        data = typeof data === 'object' ? data : {};
        let result = new ReminderNoteObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectID"] = this.objectID;
        data["objectInstanceID"] = this.objectInstanceID;
        data["objectInstanceRevNum"] = this.objectInstanceRevNum;
        data["notes"] = this.notes;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IReminderNoteObject {
    objectID?: number | undefined;
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    notes?: string | undefined;
    createdBy?: number | undefined;
}

export class RiskActionStatusObj implements IRiskActionStatusObj {
    oldWFStatusID?: number | undefined;
    newWFStatusID?: number | undefined;

    constructor(data?: IRiskActionStatusObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldWFStatusID = _data["oldWFStatusID"];
            this.newWFStatusID = _data["newWFStatusID"];
        }
    }

    static fromJS(data: any): RiskActionStatusObj {
        data = typeof data === 'object' ? data : {};
        let result = new RiskActionStatusObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldWFStatusID"] = this.oldWFStatusID;
        data["newWFStatusID"] = this.newWFStatusID;
        return data;
    }
}

export interface IRiskActionStatusObj {
    oldWFStatusID?: number | undefined;
    newWFStatusID?: number | undefined;
}

export class RiskRating implements IRiskRating {
    ratingAsOfDate?: Date | undefined;
    createdBy?: number | undefined;

    constructor(data?: IRiskRating) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ratingAsOfDate = _data["ratingAsOfDate"] ? new Date(_data["ratingAsOfDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): RiskRating {
        data = typeof data === 'object' ? data : {};
        let result = new RiskRating();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ratingAsOfDate"] = this.ratingAsOfDate ? this.ratingAsOfDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IRiskRating {
    ratingAsOfDate?: Date | undefined;
    createdBy?: number | undefined;
}

export class RiskToCarryObj implements IRiskToCarryObj {
    firmRMPID?: number | undefined;
    sourceFirmRiskID?: number | undefined;
    sourecFirmRiskVerNum?: number | undefined;
    wfStatusID?: number | undefined;
    createdBy?: number | undefined;

    constructor(data?: IRiskToCarryObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRMPID = _data["firmRMPID"];
            this.sourceFirmRiskID = _data["sourceFirmRiskID"];
            this.sourecFirmRiskVerNum = _data["sourecFirmRiskVerNum"];
            this.wfStatusID = _data["wfStatusID"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): RiskToCarryObj {
        data = typeof data === 'object' ? data : {};
        let result = new RiskToCarryObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRMPID"] = this.firmRMPID;
        data["sourceFirmRiskID"] = this.sourceFirmRiskID;
        data["sourecFirmRiskVerNum"] = this.sourecFirmRiskVerNum;
        data["wfStatusID"] = this.wfStatusID;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IRiskToCarryObj {
    firmRMPID?: number | undefined;
    sourceFirmRiskID?: number | undefined;
    sourecFirmRiskVerNum?: number | undefined;
    wfStatusID?: number | undefined;
    createdBy?: number | undefined;
}

export class SaveCommentObj implements ISaveCommentObj {
    wFirmRptPublishCommentID?: number | undefined;
    firmRptReviewItemID?: number | undefined;
    wPublishedComments?: string | undefined;
    wPublishedBy?: number | undefined;
    wPublishedDate?: Date | undefined;
    firmRptSchItemID?: number | undefined;
    wAllowResubmit?: boolean | undefined;
    objectActionItemID?: number | undefined;
    commentAsActionItemFlag?: boolean | undefined;

    constructor(data?: ISaveCommentObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wFirmRptPublishCommentID = _data["wFirmRptPublishCommentID"];
            this.firmRptReviewItemID = _data["firmRptReviewItemID"];
            this.wPublishedComments = _data["wPublishedComments"];
            this.wPublishedBy = _data["wPublishedBy"];
            this.wPublishedDate = _data["wPublishedDate"] ? new Date(_data["wPublishedDate"].toString()) : <any>undefined;
            this.firmRptSchItemID = _data["firmRptSchItemID"];
            this.wAllowResubmit = _data["wAllowResubmit"];
            this.objectActionItemID = _data["objectActionItemID"];
            this.commentAsActionItemFlag = _data["commentAsActionItemFlag"];
        }
    }

    static fromJS(data: any): SaveCommentObj {
        data = typeof data === 'object' ? data : {};
        let result = new SaveCommentObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wFirmRptPublishCommentID"] = this.wFirmRptPublishCommentID;
        data["firmRptReviewItemID"] = this.firmRptReviewItemID;
        data["wPublishedComments"] = this.wPublishedComments;
        data["wPublishedBy"] = this.wPublishedBy;
        data["wPublishedDate"] = this.wPublishedDate ? this.wPublishedDate.toISOString() : <any>undefined;
        data["firmRptSchItemID"] = this.firmRptSchItemID;
        data["wAllowResubmit"] = this.wAllowResubmit;
        data["objectActionItemID"] = this.objectActionItemID;
        data["commentAsActionItemFlag"] = this.commentAsActionItemFlag;
        return data;
    }
}

export interface ISaveCommentObj {
    wFirmRptPublishCommentID?: number | undefined;
    firmRptReviewItemID?: number | undefined;
    wPublishedComments?: string | undefined;
    wPublishedBy?: number | undefined;
    wPublishedDate?: Date | undefined;
    firmRptSchItemID?: number | undefined;
    wAllowResubmit?: boolean | undefined;
    objectActionItemID?: number | undefined;
    commentAsActionItemFlag?: boolean | undefined;
}

export class SaveUpdateAuthorizedScope implements ISaveUpdateAuthorizedScope {
    objFirmScope?: FirmScopeDto;
    lstFirmActivities?: FirmActivityDto[] | undefined;
    objPrudentialCategory?: PrudentialCategoryDto;
    objSector?: SectorDto;
    lstFirmScopeCondition?: FirmScopeConditionDto[] | undefined;
    objFirmIslamicFinance?: FirmIslamicFinanceDto;
    resetFirmSector?: boolean | undefined;
    firmSectorID?: string | undefined;

    constructor(data?: ISaveUpdateAuthorizedScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objFirmScope = _data["objFirmScope"] ? FirmScopeDto.fromJS(_data["objFirmScope"]) : <any>undefined;
            if (Array.isArray(_data["lstFirmActivities"])) {
                this.lstFirmActivities = [] as any;
                for (let item of _data["lstFirmActivities"])
                    this.lstFirmActivities!.push(FirmActivityDto.fromJS(item));
            }
            this.objPrudentialCategory = _data["objPrudentialCategory"] ? PrudentialCategoryDto.fromJS(_data["objPrudentialCategory"]) : <any>undefined;
            this.objSector = _data["objSector"] ? SectorDto.fromJS(_data["objSector"]) : <any>undefined;
            if (Array.isArray(_data["lstFirmScopeCondition"])) {
                this.lstFirmScopeCondition = [] as any;
                for (let item of _data["lstFirmScopeCondition"])
                    this.lstFirmScopeCondition!.push(FirmScopeConditionDto.fromJS(item));
            }
            this.objFirmIslamicFinance = _data["objFirmIslamicFinance"] ? FirmIslamicFinanceDto.fromJS(_data["objFirmIslamicFinance"]) : <any>undefined;
            this.resetFirmSector = _data["resetFirmSector"];
            this.firmSectorID = _data["firmSectorID"];
        }
    }

    static fromJS(data: any): SaveUpdateAuthorizedScope {
        data = typeof data === 'object' ? data : {};
        let result = new SaveUpdateAuthorizedScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objFirmScope"] = this.objFirmScope ? this.objFirmScope.toJSON() : <any>undefined;
        if (Array.isArray(this.lstFirmActivities)) {
            data["lstFirmActivities"] = [];
            for (let item of this.lstFirmActivities)
                data["lstFirmActivities"].push(item.toJSON());
        }
        data["objPrudentialCategory"] = this.objPrudentialCategory ? this.objPrudentialCategory.toJSON() : <any>undefined;
        data["objSector"] = this.objSector ? this.objSector.toJSON() : <any>undefined;
        if (Array.isArray(this.lstFirmScopeCondition)) {
            data["lstFirmScopeCondition"] = [];
            for (let item of this.lstFirmScopeCondition)
                data["lstFirmScopeCondition"].push(item.toJSON());
        }
        data["objFirmIslamicFinance"] = this.objFirmIslamicFinance ? this.objFirmIslamicFinance.toJSON() : <any>undefined;
        data["resetFirmSector"] = this.resetFirmSector;
        data["firmSectorID"] = this.firmSectorID;
        return data;
    }
}

export interface ISaveUpdateAuthorizedScope {
    objFirmScope?: FirmScopeDto;
    lstFirmActivities?: FirmActivityDto[] | undefined;
    objPrudentialCategory?: PrudentialCategoryDto;
    objSector?: SectorDto;
    lstFirmScopeCondition?: FirmScopeConditionDto[] | undefined;
    objFirmIslamicFinance?: FirmIslamicFinanceDto;
    resetFirmSector?: boolean | undefined;
    firmSectorID?: string | undefined;
}

export class SaveUpdateLicensedScopeObj implements ISaveUpdateLicensedScopeObj {
    objFirmScope?: FirmScopeDto;
    lstFirmActivities?: FirmActivityDto[] | undefined;

    constructor(data?: ISaveUpdateLicensedScopeObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objFirmScope = _data["objFirmScope"] ? FirmScopeDto.fromJS(_data["objFirmScope"]) : <any>undefined;
            if (Array.isArray(_data["lstFirmActivities"])) {
                this.lstFirmActivities = [] as any;
                for (let item of _data["lstFirmActivities"])
                    this.lstFirmActivities!.push(FirmActivityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveUpdateLicensedScopeObj {
        data = typeof data === 'object' ? data : {};
        let result = new SaveUpdateLicensedScopeObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objFirmScope"] = this.objFirmScope ? this.objFirmScope.toJSON() : <any>undefined;
        if (Array.isArray(this.lstFirmActivities)) {
            data["lstFirmActivities"] = [];
            for (let item of this.lstFirmActivities)
                data["lstFirmActivities"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaveUpdateLicensedScopeObj {
    objFirmScope?: FirmScopeDto;
    lstFirmActivities?: FirmActivityDto[] | undefined;
}

export class SectorDto implements ISectorDto {
    firmSectorID?: number | undefined;
    sectorTypeID?: number | undefined;
    lastModifiedByID?: number | undefined;
    effectiveDate?: Date | undefined;

    constructor(data?: ISectorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmSectorID = _data["firmSectorID"];
            this.sectorTypeID = _data["sectorTypeID"];
            this.lastModifiedByID = _data["lastModifiedByID"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SectorDto {
        data = typeof data === 'object' ? data : {};
        let result = new SectorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmSectorID"] = this.firmSectorID;
        data["sectorTypeID"] = this.sectorTypeID;
        data["lastModifiedByID"] = this.lastModifiedByID;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISectorDto {
    firmSectorID?: number | undefined;
    sectorTypeID?: number | undefined;
    lastModifiedByID?: number | undefined;
    effectiveDate?: Date | undefined;
}

export class StringBaseResponse implements IStringBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: string | undefined;

    constructor(data?: IStringBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): StringBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        data["response"] = this.response;
        return data;
    }
}

export interface IStringBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: string | undefined;
}

export class StringObjectDictionaryBaseResponse implements IStringObjectDictionaryBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: any; } | undefined;

    constructor(data?: IStringObjectDictionaryBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (_data["response"]) {
                this.response = {} as any;
                for (let key in _data["response"]) {
                    if (_data["response"].hasOwnProperty(key))
                        (<any>this.response)![key] = _data["response"][key];
                }
            }
        }
    }

    static fromJS(data: any): StringObjectDictionaryBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringObjectDictionaryBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (this.response) {
            data["response"] = {};
            for (let key in this.response) {
                if (this.response.hasOwnProperty(key))
                    (<any>data["response"])[key] = (<any>this.response)[key];
            }
        }
        return data;
    }
}

export interface IStringObjectDictionaryBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: any; } | undefined;
}

export class StringObjectDictionaryListBaseResponse implements IStringObjectDictionaryListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: any; }[] | undefined;

    constructor(data?: IStringObjectDictionaryListBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["response"])) {
                this.response = [] as any;
                for (let item of _data["response"])
                    this.response!.push(item);
            }
        }
    }

    static fromJS(data: any): StringObjectDictionaryListBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringObjectDictionaryListBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.response)) {
            data["response"] = [];
            for (let item of this.response)
                data["response"].push(item);
        }
        return data;
    }
}

export interface IStringObjectDictionaryListBaseResponse {
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    statusCode?: number;
    response?: { [key: string]: any; }[] | undefined;
}

export class UpdateAdminFeeObj implements IUpdateAdminFeeObj {
    firmRptAdminFee?: number | undefined;
    adminFeeRecStatusTypeID?: number | undefined;
    adminFeeStatusReason?: string | undefined;
    createdBy?: number | undefined;

    constructor(data?: IUpdateAdminFeeObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRptAdminFee = _data["firmRptAdminFee"];
            this.adminFeeRecStatusTypeID = _data["adminFeeRecStatusTypeID"];
            this.adminFeeStatusReason = _data["adminFeeStatusReason"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): UpdateAdminFeeObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAdminFeeObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRptAdminFee"] = this.firmRptAdminFee;
        data["adminFeeRecStatusTypeID"] = this.adminFeeRecStatusTypeID;
        data["adminFeeStatusReason"] = this.adminFeeStatusReason;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IUpdateAdminFeeObj {
    firmRptAdminFee?: number | undefined;
    adminFeeRecStatusTypeID?: number | undefined;
    adminFeeStatusReason?: string | undefined;
    createdBy?: number | undefined;
}

export class UpdateNoticeDetailsObj implements IUpdateNoticeDetailsObj {
    noticeID?: number | undefined;
    noticeTypeID?: number | undefined;
    noticeTemplateID?: number | undefined;
    internalReferenceNumber?: string | undefined;
    cmsReferenceNumber?: string | undefined;
    issuersReferenceNumber?: string | undefined;
    noticeIssuerID?: number | undefined;
    otherNoticeIssuer?: string | undefined;
    noticeIssuedDate?: Date | undefined;
    subject?: string | undefined;
    references?: string | undefined;
    linkToNotice?: string | undefined;
    publishOnESS?: boolean | undefined;
    publishOnWebsite?: boolean | undefined;
    recipientCriteriaCSVFirmTypeIDs?: string | undefined;
    recipientCriteriaCSVfirmIds?: string | undefined;
    recipientCriteriaCSVControlledFunctionTypeIDs?: string | undefined;
    recipientCriteriaCSVDNFBPFunctionTypeIDs?: string | undefined;
    sendNoticeToSUPSupervisor?: boolean | undefined;
    sendNoticeToAMLSupervisor?: boolean | undefined;
    emailNotificationContent?: string | undefined;
    createdBy?: number | undefined;
    opType?: string | undefined;
    otherNoticeTemplateName?: string | undefined;
    noticeOriginator?: string | undefined;
    recipientCriteriaCSVContactTypeIDs?: string | undefined;

    constructor(data?: IUpdateNoticeDetailsObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeID = _data["noticeID"];
            this.noticeTypeID = _data["noticeTypeID"];
            this.noticeTemplateID = _data["noticeTemplateID"];
            this.internalReferenceNumber = _data["internalReferenceNumber"];
            this.cmsReferenceNumber = _data["cmsReferenceNumber"];
            this.issuersReferenceNumber = _data["issuersReferenceNumber"];
            this.noticeIssuerID = _data["noticeIssuerID"];
            this.otherNoticeIssuer = _data["otherNoticeIssuer"];
            this.noticeIssuedDate = _data["noticeIssuedDate"] ? new Date(_data["noticeIssuedDate"].toString()) : <any>undefined;
            this.subject = _data["subject"];
            this.references = _data["references"];
            this.linkToNotice = _data["linkToNotice"];
            this.publishOnESS = _data["publishOnESS"];
            this.publishOnWebsite = _data["publishOnWebsite"];
            this.recipientCriteriaCSVFirmTypeIDs = _data["recipientCriteriaCSVFirmTypeIDs"];
            this.recipientCriteriaCSVfirmIds = _data["recipientCriteriaCSVfirmIds"];
            this.recipientCriteriaCSVControlledFunctionTypeIDs = _data["recipientCriteriaCSVControlledFunctionTypeIDs"];
            this.recipientCriteriaCSVDNFBPFunctionTypeIDs = _data["recipientCriteriaCSVDNFBPFunctionTypeIDs"];
            this.sendNoticeToSUPSupervisor = _data["sendNoticeToSUPSupervisor"];
            this.sendNoticeToAMLSupervisor = _data["sendNoticeToAMLSupervisor"];
            this.emailNotificationContent = _data["emailNotificationContent"];
            this.createdBy = _data["createdBy"];
            this.opType = _data["opType"];
            this.otherNoticeTemplateName = _data["otherNoticeTemplateName"];
            this.noticeOriginator = _data["noticeOriginator"];
            this.recipientCriteriaCSVContactTypeIDs = _data["recipientCriteriaCSVContactTypeIDs"];
        }
    }

    static fromJS(data: any): UpdateNoticeDetailsObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNoticeDetailsObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeID"] = this.noticeID;
        data["noticeTypeID"] = this.noticeTypeID;
        data["noticeTemplateID"] = this.noticeTemplateID;
        data["internalReferenceNumber"] = this.internalReferenceNumber;
        data["cmsReferenceNumber"] = this.cmsReferenceNumber;
        data["issuersReferenceNumber"] = this.issuersReferenceNumber;
        data["noticeIssuerID"] = this.noticeIssuerID;
        data["otherNoticeIssuer"] = this.otherNoticeIssuer;
        data["noticeIssuedDate"] = this.noticeIssuedDate ? this.noticeIssuedDate.toISOString() : <any>undefined;
        data["subject"] = this.subject;
        data["references"] = this.references;
        data["linkToNotice"] = this.linkToNotice;
        data["publishOnESS"] = this.publishOnESS;
        data["publishOnWebsite"] = this.publishOnWebsite;
        data["recipientCriteriaCSVFirmTypeIDs"] = this.recipientCriteriaCSVFirmTypeIDs;
        data["recipientCriteriaCSVfirmIds"] = this.recipientCriteriaCSVfirmIds;
        data["recipientCriteriaCSVControlledFunctionTypeIDs"] = this.recipientCriteriaCSVControlledFunctionTypeIDs;
        data["recipientCriteriaCSVDNFBPFunctionTypeIDs"] = this.recipientCriteriaCSVDNFBPFunctionTypeIDs;
        data["sendNoticeToSUPSupervisor"] = this.sendNoticeToSUPSupervisor;
        data["sendNoticeToAMLSupervisor"] = this.sendNoticeToAMLSupervisor;
        data["emailNotificationContent"] = this.emailNotificationContent;
        data["createdBy"] = this.createdBy;
        data["opType"] = this.opType;
        data["otherNoticeTemplateName"] = this.otherNoticeTemplateName;
        data["noticeOriginator"] = this.noticeOriginator;
        data["recipientCriteriaCSVContactTypeIDs"] = this.recipientCriteriaCSVContactTypeIDs;
        return data;
    }
}

export interface IUpdateNoticeDetailsObj {
    noticeID?: number | undefined;
    noticeTypeID?: number | undefined;
    noticeTemplateID?: number | undefined;
    internalReferenceNumber?: string | undefined;
    cmsReferenceNumber?: string | undefined;
    issuersReferenceNumber?: string | undefined;
    noticeIssuerID?: number | undefined;
    otherNoticeIssuer?: string | undefined;
    noticeIssuedDate?: Date | undefined;
    subject?: string | undefined;
    references?: string | undefined;
    linkToNotice?: string | undefined;
    publishOnESS?: boolean | undefined;
    publishOnWebsite?: boolean | undefined;
    recipientCriteriaCSVFirmTypeIDs?: string | undefined;
    recipientCriteriaCSVfirmIds?: string | undefined;
    recipientCriteriaCSVControlledFunctionTypeIDs?: string | undefined;
    recipientCriteriaCSVDNFBPFunctionTypeIDs?: string | undefined;
    sendNoticeToSUPSupervisor?: boolean | undefined;
    sendNoticeToAMLSupervisor?: boolean | undefined;
    emailNotificationContent?: string | undefined;
    createdBy?: number | undefined;
    opType?: string | undefined;
    otherNoticeTemplateName?: string | undefined;
    noticeOriginator?: string | undefined;
    recipientCriteriaCSVContactTypeIDs?: string | undefined;
}

export class UpdateNoticeFinalizeObj implements IUpdateNoticeFinalizeObj {
    noticeID?: number | undefined;
    opType?: string | undefined;
    updatedBy?: number | undefined;

    constructor(data?: IUpdateNoticeFinalizeObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noticeID = _data["noticeID"];
            this.opType = _data["opType"];
            this.updatedBy = _data["updatedBy"];
        }
    }

    static fromJS(data: any): UpdateNoticeFinalizeObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNoticeFinalizeObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noticeID"] = this.noticeID;
        data["opType"] = this.opType;
        data["updatedBy"] = this.updatedBy;
        return data;
    }
}

export interface IUpdateNoticeFinalizeObj {
    noticeID?: number | undefined;
    opType?: string | undefined;
    updatedBy?: number | undefined;
}

export class UpdatePublishObj implements IUpdatePublishObj {
    waiverID?: number | undefined;
    waiverRevNum?: number | undefined;
    lastModifiedBy?: number | undefined;
    publishToPR?: boolean | undefined;

    constructor(data?: IUpdatePublishObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.waiverID = _data["waiverID"];
            this.waiverRevNum = _data["waiverRevNum"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.publishToPR = _data["publishToPR"];
        }
    }

    static fromJS(data: any): UpdatePublishObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePublishObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waiverID"] = this.waiverID;
        data["waiverRevNum"] = this.waiverRevNum;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["publishToPR"] = this.publishToPR;
        return data;
    }
}

export interface IUpdatePublishObj {
    waiverID?: number | undefined;
    waiverRevNum?: number | undefined;
    lastModifiedBy?: number | undefined;
    publishToPR?: boolean | undefined;
}

export class UpdateRMPInitialObj implements IUpdateRMPInitialObj {
    firmRMPID?: number | undefined;
    wfStatusID?: number | undefined;

    constructor(data?: IUpdateRMPInitialObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRMPID = _data["firmRMPID"];
            this.wfStatusID = _data["wfStatusID"];
        }
    }

    static fromJS(data: any): UpdateRMPInitialObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRMPInitialObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRMPID"] = this.firmRMPID;
        data["wfStatusID"] = this.wfStatusID;
        return data;
    }
}

export interface IUpdateRMPInitialObj {
    firmRMPID?: number | undefined;
    wfStatusID?: number | undefined;
}

export class UpdateRMPObj implements IUpdateRMPObj {
    firmRMPID?: number | undefined;
    wfStatusID?: number | undefined;
    firmRiskActionItemStatusID?: number | undefined;

    constructor(data?: IUpdateRMPObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firmRMPID = _data["firmRMPID"];
            this.wfStatusID = _data["wfStatusID"];
            this.firmRiskActionItemStatusID = _data["firmRiskActionItemStatusID"];
        }
    }

    static fromJS(data: any): UpdateRMPObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRMPObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firmRMPID"] = this.firmRMPID;
        data["wfStatusID"] = this.wfStatusID;
        data["firmRiskActionItemStatusID"] = this.firmRiskActionItemStatusID;
        return data;
    }
}

export interface IUpdateRMPObj {
    firmRMPID?: number | undefined;
    wfStatusID?: number | undefined;
    firmRiskActionItemStatusID?: number | undefined;
}

export class UpdateStatusObj implements IUpdateStatusObj {
    objectWFTaskStatusID?: number | undefined;
    objectWFStatusTypeID?: number | undefined;
    lastModifiedBy?: number | undefined;
    taskAssignDate?: Date | undefined;

    constructor(data?: IUpdateStatusObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectWFTaskStatusID = _data["objectWFTaskStatusID"];
            this.objectWFStatusTypeID = _data["objectWFStatusTypeID"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.taskAssignDate = _data["taskAssignDate"] ? new Date(_data["taskAssignDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateStatusObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStatusObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectWFTaskStatusID"] = this.objectWFTaskStatusID;
        data["objectWFStatusTypeID"] = this.objectWFStatusTypeID;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["taskAssignDate"] = this.taskAssignDate ? this.taskAssignDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateStatusObj {
    objectWFTaskStatusID?: number | undefined;
    objectWFStatusTypeID?: number | undefined;
    lastModifiedBy?: number | undefined;
    taskAssignDate?: Date | undefined;
}

export class UpdateTasksObj implements IUpdateTasksObj {
    objectWFStatusID?: number | undefined;
    objectWFTaskStatusID?: number | undefined;
    reassignedTo?: number | undefined;
    modifiedBy?: number | undefined;
    tasksPertainingTo?: number | undefined;
    justification?: string | undefined;
    taskReAssgmntID?: number | undefined;

    constructor(data?: IUpdateTasksObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectWFStatusID = _data["objectWFStatusID"];
            this.objectWFTaskStatusID = _data["objectWFTaskStatusID"];
            this.reassignedTo = _data["reassignedTo"];
            this.modifiedBy = _data["modifiedBy"];
            this.tasksPertainingTo = _data["tasksPertainingTo"];
            this.justification = _data["justification"];
            this.taskReAssgmntID = _data["taskReAssgmntID"];
        }
    }

    static fromJS(data: any): UpdateTasksObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTasksObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectWFStatusID"] = this.objectWFStatusID;
        data["objectWFTaskStatusID"] = this.objectWFTaskStatusID;
        data["reassignedTo"] = this.reassignedTo;
        data["modifiedBy"] = this.modifiedBy;
        data["tasksPertainingTo"] = this.tasksPertainingTo;
        data["justification"] = this.justification;
        data["taskReAssgmntID"] = this.taskReAssgmntID;
        return data;
    }
}

export interface IUpdateTasksObj {
    objectWFStatusID?: number | undefined;
    objectWFTaskStatusID?: number | undefined;
    reassignedTo?: number | undefined;
    modifiedBy?: number | undefined;
    tasksPertainingTo?: number | undefined;
    justification?: string | undefined;
    taskReAssgmntID?: number | undefined;
}

export class UpdateUserProfileObj implements IUpdateUserProfileObj {
    aiNumber?: string | undefined;
    qfcNumber?: string | undefined;
    emailAddress?: string | undefined;
    userModified?: number | undefined;
    contactID?: number | undefined;

    constructor(data?: IUpdateUserProfileObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aiNumber = _data["aiNumber"];
            this.qfcNumber = _data["qfcNumber"];
            this.emailAddress = _data["emailAddress"];
            this.userModified = _data["userModified"];
            this.contactID = _data["contactID"];
        }
    }

    static fromJS(data: any): UpdateUserProfileObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserProfileObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aiNumber"] = this.aiNumber;
        data["qfcNumber"] = this.qfcNumber;
        data["emailAddress"] = this.emailAddress;
        data["userModified"] = this.userModified;
        data["contactID"] = this.contactID;
        return data;
    }
}

export interface IUpdateUserProfileObj {
    aiNumber?: string | undefined;
    qfcNumber?: string | undefined;
    emailAddress?: string | undefined;
    userModified?: number | undefined;
    contactID?: number | undefined;
}

export class UpdateWaiverScheduleObj implements IUpdateWaiverScheduleObj {
    docID?: number | undefined;
    waiverID?: number | undefined;
    waiverRevNum?: number | undefined;

    constructor(data?: IUpdateWaiverScheduleObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docID = _data["docID"];
            this.waiverID = _data["waiverID"];
            this.waiverRevNum = _data["waiverRevNum"];
        }
    }

    static fromJS(data: any): UpdateWaiverScheduleObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWaiverScheduleObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docID"] = this.docID;
        data["waiverID"] = this.waiverID;
        data["waiverRevNum"] = this.waiverRevNum;
        return data;
    }
}

export interface IUpdateWaiverScheduleObj {
    docID?: number | undefined;
    waiverID?: number | undefined;
    waiverRevNum?: number | undefined;
}

export class UpdateWaiverTypeObj implements IUpdateWaiverTypeObj {
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    waiverTypeId?: number | undefined;

    constructor(data?: IUpdateWaiverTypeObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectInstanceID = _data["objectInstanceID"];
            this.objectInstanceRevNum = _data["objectInstanceRevNum"];
            this.waiverTypeId = _data["waiverTypeId"];
        }
    }

    static fromJS(data: any): UpdateWaiverTypeObj {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWaiverTypeObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectInstanceID"] = this.objectInstanceID;
        data["objectInstanceRevNum"] = this.objectInstanceRevNum;
        data["waiverTypeId"] = this.waiverTypeId;
        return data;
    }
}

export interface IUpdateWaiverTypeObj {
    objectInstanceID?: number | undefined;
    objectInstanceRevNum?: number | undefined;
    waiverTypeId?: number | undefined;
}

export class WaiverExceptionObj implements IWaiverExceptionObj {
    notes?: string | undefined;
    dueDate?: Date | undefined;
    statusID?: number | undefined;
    actionItmID?: number | undefined;
    outputprm?: number | undefined;

    constructor(data?: IWaiverExceptionObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.statusID = _data["statusID"];
            this.actionItmID = _data["actionItmID"];
            this.outputprm = _data["outputprm"];
        }
    }

    static fromJS(data: any): WaiverExceptionObj {
        data = typeof data === 'object' ? data : {};
        let result = new WaiverExceptionObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["statusID"] = this.statusID;
        data["actionItmID"] = this.actionItmID;
        data["outputprm"] = this.outputprm;
        return data;
    }
}

export interface IWaiverExceptionObj {
    notes?: string | undefined;
    dueDate?: Date | undefined;
    statusID?: number | undefined;
    actionItmID?: number | undefined;
    outputprm?: number | undefined;
}

export class WaiverRevisionObj implements IWaiverRevisionObj {
    waiverID?: number | undefined;
    waiverRevNum?: number | undefined;
    userId?: number | undefined;

    constructor(data?: IWaiverRevisionObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.waiverID = _data["waiverID"];
            this.waiverRevNum = _data["waiverRevNum"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): WaiverRevisionObj {
        data = typeof data === 'object' ? data : {};
        let result = new WaiverRevisionObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waiverID"] = this.waiverID;
        data["waiverRevNum"] = this.waiverRevNum;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IWaiverRevisionObj {
    waiverID?: number | undefined;
    waiverRevNum?: number | undefined;
    userId?: number | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}